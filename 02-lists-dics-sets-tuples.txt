Списъци, речници и n-торки
08.03.2011г.

== Общи и вероятно споменати факти ==
 * ((Всичко е обект))
 * ((Garbage controller-ът ни пази))
 * ((Функцията `help`))
 * ((Операторът `in`))

== Колекции в Python ==
 * ((Списъци))
 * ((Речници))
 * ((Множества))
 * ((n-торки))

== Списъци ==l
 * Подредена колекция от обекти 
 * Отделните елементи се достъпват чрез индекс — цяло число
 * Обхождат се лесно
 * Променлива дължина — няма нужда да я определяме преди използване
 * Могат да бъдат променяни на място(mutable)
 * Могат да съдържат обекти от различни типове
 * Списъците могат да се влагат един в друг
 * Записват се като поредица от обекти, разделени със запетаи и оградени в средни скоби: 
{{{python
["Lancelot", ["Ni!", 8, []], "Pidgeon"]
}}}

== Да си направим списъче ==
{{{python
>>> actor = "Eric Idle"
>>> sketch = "Spam"
>>> stuff = [actor, 42, sketch]
>>> print(stuff)
['Eric Idle', 42, 'Spam']
}}}

== Основни операции със списъци ==l
 * Намиране на дължина — `len(списък)`
{{{python
>>> len(["Foo", "Bar", "Baz", "Qux"])
4
}}}
 * Събиране — `+`
{{{python
>>> [1, 2] + [3, 4]
[1, 2, 3, 4]
}}}
 * Съдържа ли се обект в списък — `in`
{{{python
>>> "Spam" in ["Eggs", "Bacon", "Spam"]
True
}}}
 * Неприсъствие на обект в списък — `not in`
{{{python
>>> "Spam" not in ["Eggs", "Bacon", "Spam"]
False
}}}

== Индексиране и рязане на списъци ==ll
{{{python
>>> cheese = ['Red Leicester', 'Cheddar', 'Emmental', 'Mozzarella', 'Tilsit', 'Limburger']
>>> cheese[0]
'Red Leicester'
>>> cheese[-1]
'Limburger'
>>> cheese[1:4]
['Cheddar', 'Emmental', 'Mozzarella']
>>> cheese[1:-1]
['Cheddar', 'Emmental', 'Mozzarella', 'Tilsit']
>>> cheese[1:]
['Cheddar', 'Emmental', 'Mozzarella', 'Tilsit', 'Limburger']
>>> cheese[:3]
['Red Leicester', 'Cheddar', 'Emmental']
>>> cheese[0:6:2]
['Red Leicester', 'Emmental', 'Tilsit']
>>> cheese[::2]
['Red Leicester', 'Emmental', 'Tilsit']
>>> cheese[::-1]
['Limburger', 'Tilsit', 'Mozzarella', 'Emmental', 'Cheddar', 'Red Leicester']
}}}

== Промяна на списъци ==l
{{{python
>>> food = ['eggs', 'bacon', 'spam']
>>> print(food)
['eggs', 'bacon', 'spam']
>>> food[1] = 'sausage'
>>> print(food)
['eggs', 'sausage', 'spam']
>>> food.append('spam')
>>> print(food)
['eggs', 'sausage', 'spam', 'spam']
>>> food.append(['манджа', 'грозде'])
>>> print(food)
['eggs', 'sausage', 'spam', 'spam', ['манджа', 'грозде']]
>>> del food[4]
>>> print(food)
['eggs', 'sausage', 'spam', 'spam']
}}}

== Интересни методи на списъците ==ll
{{{python
>>> knights = ["Arthur", "Galahad"]
>>> knights.append('Bedevere')
>>> knights
['Arthur', 'Galahad', 'Bedevere']
>>> knights.extend(['Lancelot', 'Robin']) # Може и knigts += ['Lancelot', 'Robin']
>>> knights
['Arthur', 'Galahad', 'Bedevere', 'Lancelot', 'Robin']
>>> knights.sort()
>>> knights
['Arthur', 'Bedevere', 'Galahad', 'Lancelot', 'Robin']
>>> knights.reverse()
>>> knights
['Robin', 'Lancelot', 'Galahad', 'Bedevere', 'Arthur']
>>> someone = knights.pop()
>>> print(someone, knights)
Arthur ['Robin', 'Lancelot', 'Galahad', 'Bedevere']
>>> someone = knights.pop(2)
>>> print(someone, knights)
Galahad ['Robin', 'Lancelot', 'Bedevere']
}}}


== Хайде пак малко за for ==l
 * Обхождането на списъци става с конструкцията `for`
 * Синтаксисът изглежда така: 


{{{python
        for ⟨име⟩ in ⟨нещо-за-обхождане⟩:
            ⟨блок код⟩
}}}

 * Тук `in` е част от синтаксиса, не проверка за притежание
 * `⟨нещо-за-обхождане⟩` може да е както литерал —
     `[1, 2, 3]` така и име, например `knights`
 * Операторът `break` излиза от цикъла
 * Операторът `continue` прекъсва текущата итерация и продължава изпълнението на цикъла от следващия елемент

== Обхождане на списъци ==

{{{python
>>> numbers = [1, 2, 3, 5, 7, 11, 13]
>>> answer = 0
>>> 
>>> for n in numbers:
        answer += n
>>> print(answer)
42
}}}
Ние нали ви казахме, че става лесно?

== Имена и обекти ==
В `python` операторът `=` дава ново име на съществуващ обект. <br> 
Последният не се копира. <br><br>

{{{python
>>> spam = ['Lancelot', 'Arthur']
>>> eggs = spam
>>> eggs[1] = 'Bedevere'
>>> spam
['Lancelot', 'Bedevere']
}}}

== Нищо ==
В `Python` нищото е `None` <br><br>

{{{python
>>> print(None)
None
>>> 1 is None
False
>>> if not None:
        print('None is treated as "False"')
}}}
`None is treated as "False"`

== Речници ==
 * хеш (hash)
 * карта (map)
 * асоциативен масив (associative array)

{{{python
>>> capitals = {
    'Germany': 'Berlin',
    'France': 'Paris',
    'Brazil': 'Rio de Janeiro',
    'Malaysia': 'Kuala Lumpur',
}
}}}

== Три други начина за създване на речник ==l
 * Чрез наименовани параметри към конструктора (не питайте):

{{{python
>>> dict(france="Paris", italy="Rome")
{'italy': 'Rome', 'france': 'Paris'}
}}}

 * Чрез списък от двойки
{{{python
>>> dict([('One', 'I'), ('Two', 'II')])
{'Two': 'II', 'One': 'I'}
}}}

 * Чрез списък от ключове и стойност по подразбиране
{{{python
>>> dict.fromkeys([1, 2, 3], 'Unknown')
{1: 'Unknown', 2: 'Unknown', 3: 'Unknown'}
}}}

== Основни приоми с речниците ==
{{{pyton
>>> capitals['Brazil']
'Rio de Janeiro'
>>> capitals['Brazil'] = 'Brazil'
>>> capitals['Brazil']
'Brazil'
>>> capitals['Sweden'] = 'Stockholm'
>>> capitals['Sweden']
'Stockholm'
>>> del capitals['Malaysia']
>>> capitals['Malaysia']
KeyError: 'Malaysia'
}}} 

== Полезни методи ==l
{{{python
>>> capitals.get('Assyria', "I don't know")
"I don't know"
>>> 'Sweden' in capitals
True
>>> list(capitals.keys())
['Brazil', 'Sweden', 'Germany', 'France']
>>> list(capitals.values())
['Rio de Janeiro', 'Stockholm', 'Berlin', 'Paris']
>>> len(capitals)
4
>>> capitals.pop('France')
'Paris'
}}}

== Копиране на речник ==l
{{{python
>>> numbers = {
    "One": "I",
    "Two": "II",
}

>>> numbers_copy = numbers.copy()
>>> numbers_copy
{'Two': 'II', 'One': 'I'}
>>> numbers
{'Two': 'II', 'One': 'I'}
>>> numbers.clear()
>>> numbers_copy
{'Two': 'II', 'One': 'I'}
>>> numbers
{}
}}}

== Хеш функция ==
 * Функция от вид: `обект → число`
 * Пример за низове: 
   
   `hash(s) == s[0]*31(n-1)+s[1]*31(n-2)+...+s[n-1]`

{{{python
>>> hash('abc')
1453079729188098211
>>> hash('d')
12800038501
}}}

 * Не е нужно да е инективна 

== Хеш функция за сравняване ==
 * ((Ако два обекта са еднакви по стойност, те имат еднакъв хеш))
 * ((Възможно е различни обекти да имат еднакъв хеш))
 * ((За да работят речниците и множествата, ключовете трябва да могат да се сравняват с `==`))
 * ((Добре е това да става по смислен начин))
 * ((Желателно е ключовете да са `immutable`))

== n-торки(tuples) ==ll
 * n-торките са неизменяеми `(immutable)` списъци
 * Записват се по същия начин, но с малки скоби, вместо средни:

{{{python
primes = (2, 3, 5, 7, 11, 13)
}}}

 * prime = `(2,)`, иначе ще се сметне за израза `2`
 * Можете да ги индексирате и `slice`-вате, но не и променяте:

{{{python
>>> primes[0] -> 2
>>> primes[1:4] -> (3, 5, 7)
>>> primes[5] = 17
Traceback (most recent call last):

  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
}}}

 * Могат да се влагат:

{{{python
("Foo", "Bar", ("Spam",), ("More", "Spam"))
}}}

== И те като списъците поддържат: ==
 * `+`
 * `*`
 * `1 in (1, 2)`
 * `for x in (1, 2):`
 * `.index`
 * `.count`

== Любопитни възможности ==ll
 * Ако имате n-торка, съдъiржаща само имена от лявата страна на присвояване, може да постигнете интересни ефекти:

{{{python
>>> (a, b) = 1, 2
>>> print(a)
1
}}} 

 * Всъщност скобите не са задължителни:

{{{python
>>> a, b = 1, 2
>>> a, b = b, a
>>> print(a)
2
>>> print(b)
1
}}}

 * Или:

{{{python
>>> numbers = (1, 2, 3)
>>> a, b, c = numbers
}}}

* В този ред на мисли, същото го могат и списъците

{{{python
>>> numbers = [1, 2, 3]
>>> [a, b, c] = numbers
}}}

== Още въпроси? ==
 * Страница на курса: http://fmi.py-bg.net
 * Форум на курса: http://fmi.py-bg.net/topics
