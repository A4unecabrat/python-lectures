Регулярни изрази

24.03.2011 г.

== Но преди това... ==

== Въпроси (1) ==
world.py:
{{{python
import re

def a(): pass
b = 42
_c = []
__d__ = {}
}}}

Кои имена ще са достъпни през модула при `import world`?

== Въпроси (2) ==
{{{python
import games.chess

games.chess.play()
}}}

Какво трябва да е налице за да работи този код?

== Въпроси (3) ==
Каква е разликата между
{{{python
import baba
}}}
и
{{{python
from . import baba
}}}

== Въпроси (4) ==
Какво се импортира при:
{{{python
from world import *
}}}

== За какво ще си говорим днес ==
 * ((Очевидно, регулярни изрази))
 * ((С какво ще ни улеснят живота -- в и извън рамките на Python))
 * ((Особености в Python 3))
 * ((Плюс една дребна задачка (вече традиционна) ))
{{{bare
<!-- TODO: stupid dirt! find another place for this -->
<style type="text/css">
.match {
    color: red;
    background-color: yellow;
    padding: 1px;
    font-weight: ;
}
.left {
    text-align: left;
}
</style>

}}}


== Проблематика ==
{{{bare
<p class="incremental indented">
    Работа с низове:
<p>
}}}
 * ((Търсене на по-сложна последователност от символи в низ))
 * ((Заместване на такива последователности с нещо друго))
 * ((Проверка дали даден низ отговаря на определени условия))


== Примерни проблеми -- много ==ll
 * ((Често срещано: извличане на информация от текстови и markup-документи (XML, HMTL, ...) ))
 * ((Искаме да проверим дали даден низ съдържа валиден телефонен номер))
{{{bare
<blockquote class="left incremental">
    Това означава:
    <ul>
        <li>Трябва да съдържа само цифри</li>
        <li>Може да започва с код на населеното място: `02`, `032` или `052`</li>
        <li>След кода, дължината му може да е между 5 и 7 цифри</li>
        <li>Самият номер (след кода) не може да започва с 0, 1, 2, 3 или 4</li>
    </ul>
</blockquote>
}}}
 * ((Затворете очи... Виждате ли редовете код вече?))


== Вариант за решение ==
{{{
def validate_phone_str(number):
    if '02' == number[:2]:
        return validate_phone_str(number[2:])
    elif number[:3] in {'032', '052'}:
        return validate_phone_str(number[3:])
    if all([c.isdigit() for c in number]):
        return 5 <= len(number) <= 7
    return False
}}}
 * ((Бъгав...))


== Втори вариант за решение ==
{{{
def validate_phone_re(number):
    pattern = r'^(02|032|052)?[5-9]\d{4,6}$'
    return bool(re.search(pattern, number))
}}}
 * ((Cooler, eh?))
 * ((Ще се заемем да разучим този втори вариант))


== Преди това, обещаната задачка ==l
 * ((Всичко е чудесно, но аз вече съм майстор на регулярните изрази.))
 * ((За всички вас имаме следната задача:))
{{{bare
<blockquote class="incremental left">
Да се провери дали дадено число е просто чрез един ред пайтън-код и регулярен израз. Разрешени операции са:
<ul>
    <li class="">Самото число, разбира се.</li>
    <li class=""><code>re.search</code> с подходящ шаблон.</li>
    <li class="">Употребата на низа '1'.</li>
    <li class="">Операторa <code>*</code>.</li>
</ul>
</blockquote>
<blockquote class="incremental left">Решения &mdash; по-късно.</blockquote>
}}}


== Понятия ==
 * ((Основно: "шаблон" (pattern), още "регулярен израз"))
 * ((Специални (meta) символи))
 * ((Екраниране (escape-ване) на специалните символи))


== Регулярните изрази в контекста на Пайтън ==l
 * ((`import re` -- модулът, реализиращ PCRE-функционалността))
 * ((Escape-ване на специални символи: чрез `\`))
 * ((За задаване на шаблоните обикновено се ползват raw-низовете))
 * ((Пример: `r'\s+'`))
 * ((Py3k unicode особености: unicode шаблон и низ, или 8-bit шаблон и низ -- консистентност))


== Задаване на шаблон ==
 * (( Всеки символ, освен някои специални, означава себе си. ))
 * (( Цялата магия е в специалните символи: <p>`. | ( ) [ ] { } + \ ^ $ * ?`</p> ))
 * (( `\` пред специален символ го прави неспециален такъв. ))


== Нашата помощна функция `matcher` ==
 * Примерите ще демонстрираме чрез наша функция `matcher()`.
 * Не е част от стандартната библиотека на Python :)
 * Ще ви покажем 4-те й реда код по-късно.
 * Сигнатура: `matcher(pattern, string)`.


== Пример ==
{{{bare
<pre class="prettyprint">
&gt;&gt;&gt; matcher('pat', 'Find a pattern.')
'Find a <span class="match">pat</span>tern.'
&gt;&gt;&gt; matcher('#', 'What ###?')
'What <span class="match">#</span>##?'
</pre>
}}}
 

== Магия от level 1 -- Повторения (quantifiers) ==l
Важат за непосредствено предхождащия ги символ/клас/група. Нека го означим с `s`. 
 * `s*` означава нула или повече повторения на `s`. 
 * `s+` търси едно или повече повторения на `s`. 
 * `s?` съвпада с нула или едно повторение на `s`. 
 * `s{m,n}` означава между `m` и `n` повторения на `s`, 
където можем да пропуснем `m` или `n`. `s{,n}` има смисъл на
нула до `n` повторения, а `s{m,}` &mdash; поне `m` повторения.` 


== Скоби и групиране ==l
Символите `(` и `)` се използват за логическо групиране на части от шаблона с цел:
 * Контролиране областта на влияние на дадена операция
 * Възможност за референция към "ограденото" в скобите
 * Задаване на по-специални (и не толкова често употребявани) конструкции
Повече за групите -- след малко.


== Примери ==l
{{{bare
<pre class="prettyprint">
matcher('o+', 'Goooooooogle')           # 'G<span class="match">oooooooo</span>gle'
matcher('[hH]o+', 'Hohohoho...')        # '<span class="match">Ho</span>hohoho...'
# Хм. Не искахме точно това. По-скоро:
matcher('([hH]o)+', 'Hohohoho...')      # '<span class="match">Hohohoho</span>...'
matcher('([hH]o){2,3}', 'Hohohoho...')  # '<span class="match">Hohoho</span>ho...'
</pre> 
<p class="">По подразбиране &mdash; алчно търсене за съвпадение (greedy). Деактивира се с `?` след квантора.</p> 
<pre class="prettyprint">
matcher('[hH]o+', 'Hoooooohohooo...')   # '<span class="match">Hoooooo</span>hohooo...'
matcher('[hH]o+?', 'Hoooooohohooo...')  # '<span class="match">Ho</span>ooooohohooo...'
</pre>
}}} 
 
 
== Значения на специалните символи ==ll
 * `.` съвпада с един произволен символ. По подразбиране символите за нов ред не се включват в тази група. 
 * `^` съвпада с началото на низ (или на ред, ако се работи в MULTILINE режим.) 
 * `$` съвпада с края на низ (или на ред, ако се работи в MULTILINE режим.) 
 * `|` има смисъл на или, например:
{{{bare
<pre class="prettyprint">
matcher('day|nice', 'A nice dance-day.')   # 'A <span class="match">nice</span> dance-day.'
matcher('da(y|n)ce', 'A nice dance-day.')  # 'A nice <span class="match">dance</span>-day.' 
</pre>
<p class="">NB! Единствено <code>|</code> се прилага не над непосредствените му символи/класове, а на целия низ отляво/отдясно:</p> 
<pre class="prettyprint">
matcher('ab|c|e', 'abcdef')     # '<span class="match">ab</span>cdef'
matcher('am|c|e', 'abcdef')     # 'ab<span class="match">c</span>def'
matcher('a(m)|c|e', 'abcdef')   # 'ab<span class="match">c</span>def'
</pre>
}}}


== Магия от level 2 (DRY) -- Символни класове ==ll
 * Набор от символи, заграден от `[` и `]`, например `[aeoui]`. 
 * Съвпадат с точно един от символите, описани в класа, например: 
{{{bare
<pre class="prettyprint">
&gt;&gt;&gt; matcher('[aeoui]', 'Google')
'G<span class="match">o</span>ogle'</pre>
}}}
 * Отрицание на клас -- посредством `^` в началото на класа:
{{{bare
<pre class="prettyprint">
matcher('[^CBL][aeoui]', 'Cobol')  # 'Co<span class="match">bo</span>l'
</pre>
}}}
 * Диапазони от символи:
{{{bare
<pre class="prettyprint">
&gt;&gt;&gt; matcher('[0-9]{1,3}-[a-z]', 'Figure 42-b')
'Figure <span class="match">42-b</span>'
&gt;&gt;&gt; matcher('[^a-zA-Z-]', 'Figure-42-b')
'Figure-<span class="match">4</span>2-b'
</pre>
}}}
 

== Предефинирани класове ==ll
 * ((`\d` -- една цифра; същото като `[0-9]`. ))
 * ((`\D` -- един символ, който не е цифра; същото като `[^0-9]`. ))
 * ((`\s` -- един whitespace символ -- `[\t\r\n\f\v]`. ))
 * ((`\S` -- един символ, който не е whitespace -- `[^\t\r\n\f\v]`. ))
 * ((`\w` -- една буква или цифра. ))
 * ((`\W` -- един символ, който не е буква или цифра. ))
 * ((`\b` -- нула символа, но граница на дума. ))
 * ((И други.))


== Примери за употреба на класове ==l
{{{bare
<pre class="prettyprint">
matcher(r'\d+', 'Phone number: 5551234')
# 'Phone number: <span class="match">5551234</span>'
matcher(r'\w+', 'Phone number: 5551234')
# '<span class="match">Phone</span> number: 5551234'
matcher(r'\s+', 'Phone number: 5551234') 
# 'Phone<span class="match"> </span>number: 5551234' 
</pre>
}}}


== Gandalf The Gray -- Групи ==ll
 * Групите са частите от даден шаблон, оградени в `(` и `)`. 
 * Към тях можем да се обръщаме и от самия шаблон чрез специалните класове `\1` &mdash; първата група, `\2` &mdash; втората и така нататък. 
 * Няколко примера:
{{{bare
<pre class="prettyprint incremental">
matcher(r'(\w+).*\1', 'Matches str if str repeats one of its words.');
'M<span class="match">atches str if str repeat</span>s one of its words.'
 
# Хм. Не точно. Нека опитаме пак:
matcher(r'(\b\w+\b).*\1', 'Matches str if str repeats one of its words.');
'Matches <span class="match">str if str</span> repeats one of its words.'
</pre> 
}}}


== Групи за напреднали (Gandalf The White) ==ll
 * ((`(?:...)`            -- използване на скоби, без да се създава група. ))
 * ((`(?P<name>...)`      -- текстът, отговарящ на групата, може да бъде достъпван чрез име, вместо чрез номер. ))
 * ((`(?P=name)`          -- търси съвпадение за текста, намерен по-рано от групата, кръстена `name`. ))
 * ((`(?#...)`            -- коментар, игнорира се. ))
 * ((`(?=...)`            -- съвпада, ако ... следва, но не го "консумира" (look-ahead). ))
 * ((`(?!...)`            -- съвпада, ако ... не следва. ))
 * ((`(?(id/name)yes|no)` -- търси за шаблона 'yes', ако групата с номер/име съвпада, или с (опционалния) шаблон 'no' иначе. ))
 * ((Още: `help(re)`))


== Методи на модула `re` ==l
 * ((`re.search()` -- проверява дали даден низ съдържа текст, отговарящ на зададения шаблон))
 * ((`re.match()` -- същото както горното, само че се търси за съвпадение в началото на низа))
 * ((`re.findall()` -- връща като списък всички съвпадения на шаблона в дадения низ))
 * ((`re.finditer()` -- същото като горното, но връща итератор))


== Методи на модула `re` (2) ==l
 * ((`re.sub(pattern, repl, string, count=0)` -- заместване в низ, на база на шаблон))
 * ((`re.split(pattern, string, maxsplit=0)` -- разделяне на низ на парчета, на база на шаблон))
 * ((`re.escape(pattern)` -- escape-ва всички специални за регулярен израз символи))
 * ((Пример: `re.escape('a(a)\s+')` ще върне `'a\\(a\\)\\\\s\\+'`))
 * ((Още: `help(re)` ))


== `MatchObject` ==
 * ((`group()` -- връща частта от низа, отговаряща на шаблона (и още...) ))
 * ((`start()` -- връща началото на съвпадението в низа))
 * ((`end()` -- връща края на съвпадението в низа))
 * ((`span()` -- връща (start, end) под формата на tuple))


== Флагове ==l
 * ((`re.I` (re.IGNORECASE) &mdash; case-insensitive търсене. ))
 * ((`re.L` (re.LOCALE)     &mdash; кара \w, \W, \b, \B да зависят от текущия locale. ))
 * ((`re.M` (re.MULTILINE)  &mdash; кара "^" да съвпада както с начало на низ, така и с начало на ред, докато "$" ще съвпада с край на ред или края на низа. ))
 * ((`re.S` (re.DOTALL)     &mdash; "." ще съвпада с всеки символ, включително и нов ред. ))
 * ((`re.X` (re.VERBOSE)    &mdash; режим на игнориране на white-space и коментари (за по-дългички RE). ))
 * ((`re.А` (re.ASCII)      &mdash; кара \w, \W, \b, \B, \d, \D да отговарят на съответните ASCII-класове. ))


== Кодът на `matcher()` ==
{{{
def matcher(regex, string):
    match = re.search(regex, string)
    if match is None: return string
    start, end = match.span()
    return string[:start] 
           + '<<<' + string[start:end] + '>>>' + 
           string[end:]
}}}


== На финалната права... ==
 * ((Имате ли предложения за задачата от началото?))
 * (( `'prime' if not re.search(<някакъв шаблон>, '1' * <число>) else 'not prime'` ))
 * ((Шаблонът: `r'^1?$|^(11+?)\1+$'`. Въпроси?))


== Още въпроси? ==
 * http://docs.python.org/py3k/library/re.html
 * http://docs.python.org/py3k/howto/regex.html#regex-howto
 * Страница на курса - http://fmi.py-bg.net/
 * Форуми на курса - http://fmi.py-bg.net/topics/
 * Курсът в Twitter - http://twitter.com/pyfmi


== XKCD ==
{{{bare
<a href="http://xkcd.com/208/" title="Wait, forgot to escape a space.  Wheeeeee[taptaptap]eeeeee." style="position: absolute; top: 0; right: 0; left: 0; padding: 0.3em 2em 0 2em; text-align: center; background: #fff;">
    <img src="06-re/regular_expressions.png" border="0" />
</a>
}}}
