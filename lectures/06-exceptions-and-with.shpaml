section.slide
    h2 | Преди това
    p
        | Ако все още се чудите защо да не използвате Python 2
    p
        a href="http://www.python.org/dev/peps/pep-0404/" | PEP 404 - Python 2.8 Un-release Schedule
section.slide
    h2 | Традицията повелява
    pre.prettyprint
        | """Модул за зимнината на Митьо Питона"""
        | import jars

        | ERROR = -1
        | SUCCESS = 0

        | def prepare_for_winter():
        |     jar = jars.Jar()
        |     if jar.clean() == jars.ERROR:
        |         print("Shit happens")
        |         return ERROR
        |     if jar.fill('python juice') == jars.ERROR:
        |         print("Shit happens")
        |         return ERROR
        |     if jar.close() == jars.ERROR:
        |         print("Shit happens")
        |         return ERROR
        |     return SUCCESS
section.slide
    h2 | Традициите не са това…
    pre.prettyprint
        | """Модул за зимнината на Митьо Питона"""
        | import jars

        | class MityoWinterError(Exception): pass

        | def prepare_for_winter():
        |     try:
        |         jar = jars.Jar()
        |         jar.clean()
        |         jar.fill('python juice')
        |         jar.close()
        |     except jars.Error:
        |         print("Shit happens")
section.slide
    h2 | Синтаксис и семантика
    pre.prettyprint
        | try:
        |     блок
        | except изключения:
        |     блок ако се случи някое от описаните изключения

        | …

        | except още изключения:
        |     блок ако се случи някое от описаните изключения
        | except:
        |     блок ако изключението не е хванато по-горе
        | else:
        |     блок ако не е възникнала изключителна ситуация
        | finally:
        |     блок изпълнява се винаги
section.slide
    h2 | Вградените изключения
    p | Основният, който всички наследяват е BaseException, но най-съществените наследяват от Exception

    ul
        li
            | <em>StandardError</em>
            |    родител на всички вградени изключения; директен наследник на <em>Exception</em>
        li
            | <em>ArithmeticError</em>
            |     родител на <em>OverflowError, ZeroDivisionError, FloatingPointError</em>
        li
            | <em>LookupError</em>
            |    родител на <em>IndexError, KeyError</em>
        li
            | <em>EnvironmentError</em>
            |     родител на изключенията, които се случват извън интерпретора: <em>IOError, OSError</em>
section.slide
    h2 | Повече информация рядко е излишна
    pre.prettyprint
        | try:
        |     x = [] / 4
        | except TypeError as data:
        |     print(data)

    p | Какво ще има в data, зависи от самото изключение, но е прието всички да връщат годна за отпечатване стойност, ако се дадат като аргументи на str или repr.
section.slide
    h2 | Ако за няколко изключения имаме една и съща реакция, можем да ги прихванем накуп
    pre.prettyprint
        | try:
        |     doomed()
        | except (NameError, TypeError) as data:
        |     print(data)
        | except (MyError, YourError):
        |     print("Opps! This shouldn't've hapenned...")
        | except:
        |     print("Unknown exception.")
        | else:
        |     print("It's my happy day!")
    p | С празен except прихващаме изключения, които не са били хванати до момента. Трябва да бъде поставен след всички други except-и.
section.slide
    h2 | finally
    pre.prettyprint
        | file = open('data.txt')
        | try:
        |     mymodule.load_info(file)
        | except IOError as data:
        |     print("Couldn't read from file:", data)
        | except (mymodule.BadDataError, mymodule.InternalError) as data:
        |     print('Loading failed:', data)
        | else:
        |     print('Data loaded successfully from file.')
        | finally:
        |     file.close()
    p | Ако присъства, finally стои винаги най-отдолу.
section.slide
    h2 | Създаване на изключения
    pre.prettyprint
        | class XmasError(Exception):
        |     def __init__(self):
        |         self.issuer, self.message = 'Robosanta', 'watches you'

        | class NaughtyError(XmasError):
        |     def __init__(self):
        |         super().__init__()
        |         self.message = 'You were very naughty this year!'

        | class AreYouDeadYetError(XmasError):
        |     def __init__(self):
        |         super().__init__()
        |         self.message = 'Are you dead yet?'

        | def confess_sins(): raise NaughtyError

        | def celebrate_xmas(): raise AreYouDeadYetError
section.slide
    h2 | Ескалиране на грешката
    ul
        li | Когато Python се натъкне на изключение в даден блок и в него то не се обработи, изключението се праща към горния блок, после към по-горния и така докато или изключението не бъде прехванато или не стигнем най-отгоре и интерпретаторът не спре програма по познатия ни вече начин (в червеничко).
        li | Можем да се намесим в следната схема или като прихванем изключението (вече знаем как), или като пратим изключението нагоре по трасето. Последното става с голо извикване на raise:
    pre.prettyprint
        | try:
        |     bender.live_a_day()
        | except BenderError:
        |     bender.boned = True
        |     # Бендър не може да се оправя с това, нека тези отгоре да се грижат
        |     raise
section.slide
    h2 | Подходи
    ul
        li | Look Before You Leap (LBYL)
        li | Easier to Ask for Forgiveness than Permission (EAFP)
section.slide
    h2 | Нека обобщим
    p | Няколко неща, за които може да ползваме изключения:

    p | обработка на грeшки:
    ul
        li | структурирани, прихващаеми, позволяващи предаване на допълнителна информация
        li | вградените функции и твърдения широко ги използват
        li | пораждане и прихващане на собствени изключения
    p | безусловно извършване на заключителни действия — <strong>finally</strong>
section.slide
    h2 | Finally <em>finally</em>?
    ul
        li | Искаме да обърнем реда на редовете на файл?
    pre.prettyprint
        | try:
        |     source_file = open(src, 'r')
        |     buffer = []
        |     try:
        |         buffer = source_file.readlines()
        |     finally:
        |         source_file.close()

        |     target_file = open(target, 'w')
        |     try:
        |         for line in reversed(buffer):
        |             target_file.write(line)
        |     finally:
        |         target_file.close()
        | except IOError:
        |     print("Tough luck, junior")


section.slide
    h2 | Too long; didn't read?
    pre.prettyprint
        | buffer = []
        | try:
        |     with open(src) as source_file:
        |         buffer = source_file.readlines()
        |     with open(target) as target_file:
        |         for line in reversed(buffer):
        |             target_file.write(line)
        | except IOError:
        |     print("Much better, now, ain't it?")
    ul
        li | <em>with</em> гарантира, че файлът ще бъде затворен автоматично.


section.slide
    h2 | with
    pre.prettyprint
        | with израз [as име]:
        |    блок
    ul
        li | Резултатът от израза се нарича Context Manager
        li | Изпълнява се метода <em>__enter__()</em> на <abbr title='Context Manager'>CM</abbr> и резултатът се записва в името след <em>as</em>
        li | Изпълнява се блока
        li | Ако е настъпило излючение се изпълнява <em>__exit__(type, value, traceback)</em> на <abbr title='Context Manager'>CM</abbr>
        li | Ако <em>не е</em> настъпило излючение се изпълнява <em>__exit__(None, None, None)</em> на <abbr title='Context Manager'>CM</abbr>

section.slide
    h2 | with нагледно
    pre.prettyprint
        | with open('/etc/passwd') as source_file:
        |     buffer = source_file.readlines()
        | print('Done!')

    p | е същото като
    pre.prettyprint
        | source_file = open('/etc/passwd').__enter__()
        | try:
        |   buffer = source_file.readlines()
        |   source_file.__exit__(None, None, None)
        | except Exception:
        |   source_file.__exit__(*sys.exc_info())
        | print('Done!')


section.slide
    h2 | Малък пример
    pre.prettyprint
        | class Manager:
        |     def __enter__(self):
        |         print("I've been entered!")
        |         return 42
        |     def __exit__(self, type, value, traceback):
        |         print("I've been exited!")

        | with Manager() as something:
        |     print("Am I inside?")
        |     print(something)

        | # I've been entered!
        | # Am I inside?
        | # 42
        | # I've been exited!

section.slide
    h2 | with с няколко аргумента
    pre.prettyprint
        | with foo() as f, bar() as b:
        |    ...

    p | е същото като

    pre.prettyprint
        | with foo() as f:
        |     with bar() as b:
        |        ...

section.slide
    h2 | contextlib
    p | Вграденият модул <em>contextlib</em> ни предлага три много полезни Context Manager-а:
    ul
        li | <em>closing</em>
        li | <em>contextmanager</em>
        li | <em>ContextDecorator</em>

section.slide
    h2 | closing

    p | <em>contextlib.closing</em> вика метода <em>close</em> на обекта, с който работим, след изпълнение на блока:

    pre.prettyprint
        | class closing(object):
        |     def __init__(self, thing): self.thing = thing
        |     def __enter__(self): return thing
        |     def __exit__(self, type, value, traceback):
        |         self.thing.close()

    p | ...и ви позволява да пишете следното:

    pre.prettyprint
        | from contextlib import closing
        | import codecs

        | with closing(urllib.urlopen('http://www.python.org')) as page:
        |     for line in page:
        |         print(line)

