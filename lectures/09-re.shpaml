div:
    <style type="text/css">
    .match {
        color: red;
        background-color: yellow;
        padding: 2px;
        border: 2px solid black;
    }
    .left {
        text-align: left;
    }
    </style>

section.slide
    h2 | За какво ще си говорим днес 
    ul
        li.slides | Очевидно, регулярни изрази
        li.slides | С какво ще ни улеснят живота -- в и извън рамките на Python
        li.slides | Особености в Python 3
        li.slides | Плюс една дребна задачка (вече традиционна) 


section.slide
    h2 | Проблематика 
    p | Работа с низове:
    ul
        li.slides | Търсене на по-сложна последователност от символи в низ
        li.slides | Заместване на такива последователности с нещо друго
        li.slides | Проверка дали даден низ отговаря на определени условия


section.slide
    h2 | Примерни проблеми -- много 
    ul
        li.slides | Често срещано: извличане на информация от текстови и markup-документи (XML, HMTL, ...) 
        li.slides | Искаме да проверим дали даден низ съдържа валиден телефонен номер
    p | Това означава:
    ul
        li | Трябва да съдържа само цифри
        li | Може да започва с код на населеното място: <em>02</em>, <em>032</em> или <em>052</em>
        li | След кода, дължината му може да е между 5 и 7 цифри
        li | Самият номер (след кода) не може да започва с 0, 1, 2, 3 или 4
        li.slides | Затворете очи... Виждате ли редовете код вече?


section.slide
    h2 | Вариант за решение 
    pre.prettyprint:
        def validate_phone_str(number):
            if '02' == number[:2]:
                return validate_phone_str(number[2:])
            elif number[:3] in {'032', '052'}:
                return validate_phone_str(number[3:])
            if all([c.isdigit() for c in number]):
                return 5 <= len(number) <= 7
            return False
    ul
        li.slides | Бъгав...


section.slide
    h2 | Втори вариант за решение 
    pre.prettyprint:
        def validate_phone_re(number):
            pattern = r'^(02|032|052)?[5-9]\d{4,6}$'
            return bool(re.search(pattern, number))
    ul
        li.slides | Cooler, eh?
        li.slides | Ще се заемем да разучим този втори вариант


section.slide
    h2 | Преди това, обещаната задачка 
    p | Всичко е чудесно, но аз вече съм майстор на регулярните изрази.
    p | За всички вас имаме следната задача:
    p | Да се провери дали дадено число е просто чрез един ред пайтън-код и регулярен израз. Разрешени операции са
    ul
        li | Самото число, разбира се.
        li | <code>re.search</code> с подходящ шаблон.
        li | Употребата на низа '1'.
        li | Операторa <code>*</code>.
    p | Решения по-късно


section.slide
    h2 | Понятия 
    ul
        li.slides | Основно: "шаблон" (pattern), още "регулярен израз"
        li.slides | Специални (meta) символи
        li.slides | Екраниране (escape-ване) на специалните символи


section.slide
    h2 | Регулярните изрази в контекста на Пайтън 
    ul
        li.slides | <em>import re</em> -- модулът, реализиращ PCRE-функционалността
        li.slides | Escape-ване на специални символи: чрез <em>\</em>
        li.slides | За задаване на шаблоните обикновено се ползват raw-низовете
        li.slides | Пример: <em>r'\s+'</em>
        li.slides | Py3k unicode особености: unicode шаблон и низ, или 8-bit шаблон и низ -- консистентност


section.slide
    h2 | Задаване на шаблон 
    ul
        li.slides |  Всеки символ, освен някои специални, означава себе си. 
        li.slides |  Цялата магия е в специалните символи: <p><em>. \| ( ) [ ] { } + \ ^ $ * ?</em></p> 
        li.slides |  <em>\</em> пред специален символ го прави неспециален такъв. 


section.slide
    h2 | Нашата помощна функция <em>matcher</em> 
    ul
        li | Примерите ще демонстрираме чрез наша функция <em>matcher()</em>.
        li | Не е част от стандартната библиотека на Python :)
        li | Ще ви покажем 4-те й реда код по-късно.
        li | Сигнатура: <em>matcher(pattern, string)</em>.


section.slide
    h2 | Пример 
    pre.prettyprint:
        &gt;&gt;&gt; matcher('pat', 'Find a pattern.')
        'Find a <span class="match">pat</span>tern.'
        &gt;&gt;&gt; matcher('#', 'What ###?')
        'What <span class="match">#</span>##?'
 

section.slide
    h2 | Магия от level 1 -- Повторения (quantifiers) 
    p | Важат за непосредствено предхождащия ги символ/клас/група. Нека го означим с <em>s</em>. 
    ul
        li | <em>s*</em> означава нула или повече повторения на <em>s</em>. 
        li | <em>s+</em> търси едно или повече повторения на <em>s</em>. 
        li | <em>s?</em> съвпада с нула или едно повторение на <em>s</em>. 
        li | <em>s{m,n}</em> означава между <em>m</em> и <em>n</em> повторения на <em>s</em>, където можем да пропуснем <em>m</em> или <em>n</em>. <em>s{,n}</em> има смисъл на нула до <em>n</em> повторения, а <em>s{m,}</em> &mdash; поне <em>m</em> повторения.` 


section.slide
    h2 | Скоби и групиране 
    p | Символите <em>(</em> и <em>)</em> се използват за логическо групиране на части от шаблона с цел:
    ul
        li | Контролиране областта на влияние на дадена операция
        li | Възможност за референция към "ограденото" в скобите
        li | Задаване на по-специални (и не толкова често употребявани) конструкции
    p | Повече за групите -- след малко.


section.slide
    h2 | Примери 
    pre.prettyprint:
        matcher('o+', 'Goooooooogle')           # 'G<span class="match">oooooooo</span>gle'
        matcher('[hH]o+', 'Hohohoho...')        # '<span class="match">Ho</span>hohoho...'
        # Хм. Не искахме точно това. По-скоро:
        matcher('([hH]o)+', 'Hohohoho...')      # '<span class="match">Hohohoho</span>...'
        matcher('([hH]o){2,3}', 'Hohohoho...')  # '<span class="match">Hohoho</span>ho...'
    p | По подразбиране &mdash; алчно търсене за съвпадение (greedy). Деактивира се с <em>?</em> след квантора.
    pre.prettyprint:
        matcher('[hH]o+', 'Hoooooohohooo...')   # '<span class="match">Hoooooo</span>hohooo...'
        matcher('[hH]o+?', 'Hoooooohohooo...')  # '<span class="match">Ho</span>ooooohohooo...'
 
 
section.slide
    h2 | Значения на специалните символи 
    ul
        li | <em>.</em> съвпада с един произволен символ. По подразбиране символите за нов ред не се включват в тази група. 
        li | <em>^</em> съвпада с началото на низ (или на ред, ако се работи в MULTILINE режим.) 
        li | <em>$</em> съвпада с края на низ (или на ред, ако се работи в MULTILINE режим.) 

section.slide
    h2 | Значения на специалните символи 
    ul
        li | <b>|</b> има смисъл на или, например:
    pre.prettyprint:
        matcher('day|nice', 'A nice dance-day.')   # 'A <span class="match">nice</span> dance-day.'
        matcher('da(y|n)ce', 'A nice dance-day.')  # 'A nice <span class="match">dance</span>-day.' 
    p | NB! Единствено <code>|</code> се прилага не над непосредствените му символи/класове, а на целия низ отляво/отдясно: 
    pre.prettyprint:
        matcher('ab|c|e', 'abcdef')     # '<span class="match">ab</span>cdef'
        matcher('am|c|e', 'abcdef')     # 'ab<span class="match">c</span>def'
        matcher('a(m)|c|e', 'abcdef')   # 'ab<span class="match">c</span>def'


section.slide
    h2 | Магия от level 2 (DRY) -- Символни класове 
    ul
        li | Набор от символи, заграден от <em>[</em> и <em>]</em>, например <em>[aeoui]</em>. 
        li | Съвпадат с точно един от символите, описани в класа, например: 
    pre.prettyprint:
        &gt;&gt;&gt; matcher('[aeoui]', 'Google')
        'G<span class="match">o</span>ogle'
    ul
        li | Отрицание на клас -- посредством <em>^</em> в началото на класа:
    pre.prettyprint
        matcher('[^CBL][aeoui]', 'Cobol')  # 'Co<span class="match">bo</span>l'
    ul
        li | Диапазони от символи:
    pre.prettyprint:
        &gt;&gt;&gt; matcher('[0-9]{1,3}-[a-z]', 'Figure 42-b')
        'Figure <span class="match">42-b</span>'
        &gt;&gt;&gt; matcher('[^a-zA-Z-]', 'Figure-42-b')
        'Figure-<span class="match">4</span>2-b'
 
section.slide
    h2 | Предефинирани класове 
    ul
        li.slides | <em>\d</em> -- една цифра; същото като <em>[0-9]</em>. 
        li.slides | <em>\D</em> -- един символ, който не е цифра; същото като <em>[^0-9]</em>. 
        li.slides | <em>\s</em> -- един whitespace символ -- <em>[\t\r\n\f\v]</em>. 
        li.slides | <em>\S</em> -- един символ, който не е whitespace -- <em>[^\t\r\n\f\v]</em>. 
        li.slides | <em>\w</em> -- една буква или цифра. 
        li.slides | <em>\W</em> -- един символ, който не е буква или цифра. 
        li.slides | <em>\b</em> -- нула символа, но граница на дума. 
        li.slides | И други.


section.slide
    h2 | Примери за употреба на класове 
    pre.prettyprint:
        matcher(r'\d+', 'Phone number: 5551234')
        # 'Phone number: <span class="match">5551234</span>'
        matcher(r'\w+', 'Phone number: 5551234')
        # '<span class="match">Phone</span> number: 5551234'
        matcher(r'\s+', 'Phone number: 5551234') 
        # 'Phone<span class="match"> </span>number: 5551234' 


section.slide
    h2 | Gandalf The Gray -- Групи 
    ul
        li | Групите са частите от даден шаблон, оградени в <em>(</em> и <em>)</em>. 
        li | Към тях можем да се обръщаме и от самия шаблон чрез специалните класове <em>\1</em> &mdash; първата група, <em>\2</em> &mdash; втората и така нататък. 
        li | Няколко примера:
    pre.prettyprint:
        matcher(r'(\w+).*\1', 'Matches str if str repeats one of its words.');
        'M<span class="match">atches str if str repeat</span>s one of its words.'
         
        # Хм. Не точно. Нека опитаме пак:
        matcher(r'(\b\w+\b).*\1', 'Matches str if str repeats one of its words.');
        'Matches <span class="match">str if str</span> repeats one of its words.'

section.slide
    h2 | Групи за напреднали (Gandalf The White) 
    ul
        li.slides | <em>(?:...)</em>            -- използване на скоби, без да се създава група. 
        li.slides | <em>(?P<name>...)</em>      -- текстът, отговарящ на групата, може да бъде достъпван чрез име, вместо чрез номер. 
        li.slides | <em>(?P=name)</em>          -- търси съвпадение за текста, намерен по-рано от групата, кръстена <em>name</em>. 
        li.slides | <em>(?#...)</em>            -- коментар, игнорира се. 
        li.slides | <em>(?=...)</em>            -- съвпада, ако ... следва, но не го "консумира" (look-ahead). 
        li.slides | <em>(?!...)</em>            -- съвпада, ако ... не следва. 
        li.slides | <em>(?(id/name)yes|no)</em> -- търси за шаблона 'yes', ако групата с номер/име съвпада, или с (опционалния) шаблон 'no' иначе. 
        li.slides | Още: <em>help(re)</em>


section.slide
    h2 | Методи на модула <em>re</em> 
    ul
        li.slides | <em>re.search()</em> -- проверява дали даден низ съдържа текст, отговарящ на зададения шаблон
        li.slides | <em>re.match()</em> -- същото както горното, само че се търси за съвпадение в началото на низа
        li.slides | <em>re.findall()</em> -- връща като списък всички съвпадения на шаблона в дадения низ
        li.slides | <em>re.finditer()</em> -- същото като горното, но връща итератор


section.slide
    h2 | Методи на модула <em>re</em> (2) 
    ul
        li.slides | <em>re.sub(pattern, repl, string, count=0)</em> -- заместване в низ, на база на шаблон
        li.slides | <em>re.split(pattern, string, maxsplit=0)</em> -- разделяне на низ на парчета, на база на шаблон
        li.slides | <em>re.escape(pattern)</em> -- escape-ва всички специални за регулярен израз символи
        li.slides | Пример: <em>re.escape('a(a)\s+')</em> ще върне <em>'a\\(a\\)\\\\s\\+'</em>
        li.slides | Още: <em>help(re)</em> 


section.slide
    h2 | <em>MatchObject</em> 
    ul
        li.slides | <em>group()</em> -- връща частта от низа, отговаряща на шаблона (и още...) 
        li.slides | <em>start()</em> -- връща началото на съвпадението в низа
        li.slides | <em>end()</em> -- връща края на съвпадението в низа
        li.slides | <em>span()</em> -- връща (start, end) под формата на tuple


section.slide
    h2 | Флагове 
    ul
        li.slides | <em>re.I</em> (re.IGNORECASE) &mdash; case-insensitive търсене. 
        li.slides | <em>re.L</em> (re.LOCALE)     &mdash; кара \w, \W, \b, \B да зависят от текущия locale. 
        li.slides | <em>re.M</em> (re.MULTILINE)  &mdash; кара "^" да съвпада както с начало на низ, така и с начало на ред, докато "$" ще съвпада с край на ред или края на низа. 
        li.slides | <em>re.S</em> (re.DOTALL)     &mdash; "." ще съвпада с всеки символ, включително и нов ред. 
        li.slides | <em>re.X</em> (re.VERBOSE)    &mdash; режим на игнориране на white-space и коментари (за по-дългички RE). 
        li.slides | <em>re.А</em> (re.ASCII)      &mdash; кара \w, \W, \b, \B, \d, \D да отговарят на съответните ASCII-класове. 


section.slide
    h2 | Кодът на <em>matcher()</em> 
    pre.prettyprint:
        def matcher(regex, string):
            match = re.search(regex, string)
            if match is None: return string
            start, end = match.span()
            return string[:start] 
                   + '<<<' + string[start:end] + '>>>' + 
                   string[end:]


section.slide
    h2 | На финалната права... 
    ul
        li.slides | Имате ли предложения за задачата от началото?
        li.slides |  <em>'prime' if not re.search(<някакъв шаблон>, '1' * <число>) else 'not prime'</em> 
        li.slides | Шаблонът: <em>r'^1?$|^(11+?)\1+$'</em>. Въпроси?
section.slide
    h2 | XKCD 
    div
        <img src="http://2011.fmi.py-bg.net/slides/06-re/regular_expressions.png" border="0" />
