section.slide
    h2 | Къде отива кода?
    ul
        li |  Код се пише в <em>.py</em> файлове (например <em>gameoflife.py</em>).
        li |  Изпълнява се с <em>python3 gameoflife.py</em>
        li |  Можем да пишем код интерактивно като пуснем <em>python3</em> без аргументи.

section.slide
    h2 | Python е предсказуем
    p | Когато не сте сигурни, просто пробвайте.
    pre.prettyprint        | $ python3
        | >>> 5 + 10
        | 15
        | >>> a = 5
        | >>> b = a + 10
        | >>> print(b)
        | 15
        | >>> a * 2
        | 10
        | >>> a ** 2
        | 25
        | >>> "hello" + ', ' + "world"
        | "hello, world"

section.slide
    h2 | Първа помощ
    p | В интерактивната конзола, <em>help()</em> показва документацията на всяка функция, клас или тип.
    pre.prettyprint
        | >>> help(str)
        | >>> help(5)
        | >>> help(SomeClass)
        | >>> help(some_function)

section.slide
    h2 | Един ред код
    ul
        li |  Съдържа един израз, никога не завършва с ;
        li |  Всичко след # е коментар
    pre.prettyprint
        | my_var = human_readable_num(50).upper()
        | print(my_var) # FIFTY


section.slide
    h2 | Типове: <em>int</em>
    ul
        li |  Цели числа, положителни и отрицателни
        li |  Стандартни операции: <em>+</em>, <em>-</em>, <em>*</em>, <em>/</em>, <em>**</em> (степенуване)
        li |  Без максимален размер
        li |  Пробвай <em>2 ** 4 ** 8</em> (степенуване)

section.slide
    h2 | Типове: <em>str</em>
    ul
        li |  Текстови низове с произволна дължина
        li |  Единични или двойни кавички
        li |  Unicode навсякъде
        li |  Поддържат \n, \t и пр.
        li |  (Но в Python 2.x има <em>str</em> и <em>unicode</em> типове, първото е ASCII.)
    pre.prettyprint
        | >>> "hello".upper()
        | "HELLO"
        | >>> len("абвгдеж")
        | 7
        | >>> "hello"[1]
        | "e"
        | >>> help(str)

section.slide
    h2 | Типове: <em>bool</em>
    ul
        li |  True и False, не забравяйте главните букви
        li |  True == 1
        li |  False == 0

section.slide
    h2 | Типове: <em>None</em>
    ul
        li |  Като <em>null</em> в другите езици
        li |  Когато една функция не върне нищо, тя връща None

section.slide
    h2 | Типове
    ul
        li |  Всяка стойност има тип, включително функциите.
        li |  Всеки стойност е обект и има клас, включително функциите.
        li |  Всичко е обект, включително функциите и типовете!
        li |  Можем да видим типа на нещо с <em>type()</em>
     pre.prettyprint
         | >>> type(5.5)
         | <class 'float'>
         | >>> type(type)
         | <class 'type'>
         | >>> type(type(type(type)))
         | <class 'type'>

section.slide
    h2 | Имена
    ul
        li
            Можем да дадем име на стойност и получаваме променлива.
            pre.prettyprint | velocity = distance / 60
        li  |  Динамичен език - стойностите имат тип, но имената - не.
    pre.prettyprint
        | а = 5
        | type(a) # <class 'int'>
        | a = 'test'
        | type(a) # <class 'str'>

section.slide
    h2 | Структури от данни
    ul
        li |  Списък (<em>list</em>)
        li |  Речник (<em>dict</em>)
        li |  Tuple (<em>tuple</em>)
        li |  Множество (<em>set</em>)
        li |  Както винаги: <em>help(dict)</em>

section.slide
    h2 | Списъци
    ul
        li |  Списък = list = масив = array
        li |  Mutable и без фиксирана дължина
        li |  Бързи за търсене по индекс, бавни за търсене по стойност
        li |  Гарантиран ред
        li |  Могат да се смесват типове

    pre.prettyprint
        | my_list = []
        | my_list = list()

section.slide
    h2 | Списъци (2)
    pre.prettyprint
        | my_list = []
        | my_list.append('word')
        | my_list.append(5)
        | my_list.append(False)
        | my_list[1] == 5
        | my_other_list = ['foo', 'bar', 'quux']
        | len(my_other_list) # 3
        | del my_other_list[1]
        | print(my_other_list) # ['foo', 'quux']
        | 'foo' in my_other_list # True
        | False in my_list # True

section.slide
    h2 | Речник (<em>dict</em>)
    ul
        li |  Речник = <em>dict</em> = hashtable = associative array
        li |  Реда не е гарантиран
        li |  Асоциира ключ със стойност
    pre.prettyprint
        | ages = {'Кай': 1, 'Бобо': 2}
        | ages['Йоан'] = 24
        | ages['Алек'] = 25
        | ages['Стефан'] = 25
        | ages['Кирил'] = 25
        | ages['Николай'] = 27
        | ages['Алек'] = 26 # ЧРД
        | print(ages['Кирил']) # 25
        | 'Николай' in ages # True
        | ages.get('Георги') # None
        | ages.get('Георги', 'няма такъв') # няма такъв

section.slide
    h2 | <em>tuple</em>
    ul
        li |  Tuple = n-торка = списък, който не може да бъде променян
        li |  Гарантиран ред
        li |  Ползват за да подадете или върнете няколко стойности от функция, когато специален клас би би твърде много
    pre.prettyprint
        | >>> args = (9.8, 3.14, 2.71)
        | >>> args[2]
        | 2.71
        | >>> args[1] = 22/7
        | Traceback (most recent call last):
        | File "<stdin>", line 1, in <module>
        | TypeError: 'tuple' object does not support item assignment
    ul
        li |  Tuple от един елемент - със запетайка на края: <em>('Your friends will never love you.',)</em>

section.slide
    h2 | Структури от данни: <em>set</em>
    ul
        li |  Set = множество = списък без повтарящи се елементи
        li |  Реда не е гарантиран
        li |  Спомнете си теория на категориите
    pre.prettyprint
        | >>> unique_numbers = {2,3,5,6}
        | >>> unique_numbers
        | {2, 3, 5, 6}
        | >>> unique_numbers.add(5)
        | >>> unique_numbers
        | {2, 3, 5, 6}
        | >>> unique_numbers.remove(5)
        | >>> unique_numbers
        | {2, 3, 6}
        | >>> my_list = [5,1,6,6,2,3,5,5]
        | >>> set(my_list)
        | {1, 2, 3, 5, 6}

section.slide
    h2 | Mutable vs immutable
    ul
        li |  Immutable са стойностите, които не могат да бъдат променяни.
    pre.prettyprint
        | а = 5
        | а += 2 # 7
    p | Този код не променя стойноста на 5, а кара <em>а</em> да сочи към друга стойност (7). Числата са immutable.
    pre.prettyprint
        | а = [1,2,3]
        | a.append(4)
    p | Този код променя списъка, към който сочи <em>a</em>. Списъците са mutable.
    ul
        li |  Immutable са числа, низове, tuples, True, False, None, дата/час (datetime), класове и функции.
        li |  Всичко останало е mutable.
        li |  Като ключ на <em>dict</em> или елемент на <em>set</em> могат да се ползват само immutable стойности.

section.slide
    h2 | Контролни структури
    ul
        li |  if .. elif .. else
        li |  while
        li |  for

section.slide
    h2 | if
    ul
        li |  Точно каквото очаквахте.
    pre.prettyprint
        | if a == 5:
        |     print("a is five")
        | elif a == 3 and not b == 2:
        |     print("a is three, b is not two")
        | else:
        |     print("a is something else")
    ul
        li |  Не слагайте скоби около условията.
        li |  <em>and</em> и <em>or</em> и <em>not</em> вместо <em>&&</em>, <em>||</em>, <em>!</em>

section.slide
    h2 | <em>if</em>
    p | Още булеви тестове:
    pre.prettyprint
        | a = True
        | if a:
        |     print("a is True")

        | if not a:
        |     print("a is not True")

section.slide
    h2 | Индентация
    ul
        li |  Къде са къдравите скоби?!
        li |  Всеки вложен блок код (тяло на if, тяло на функция, и т.н.) се определя с индентацията му спрямо предишния блок.
        li |  Блокът свършва, когато се върнете към предишната индентация.
        li |  4 празни места = нов блок. Не 3, не 5, не табулация.
        li |  Настройте редактора си да слага 4 празни места когато натиснете Tab.

section.slide
    h2 | <em>while</em>
    pre.prettyprint
        | while a > 5:
        |     a -= 1
        |     print("a is %d" % a)

section.slide
    h2 | <em>for</em>
    ul
        li |  <em>for</em> е като <em>foreach</em> в другите езици
        li |  Не увеличава индекси, а обхожда структури от данни
    pre.prettyprint
        | primes = [3,5,7,11]
        | for e in primes:
        |     print(e ** 2) # prints 9 25 49 121

        | people = {'bob': 25, 'john': 22, 'mitt': 56}
        | for name, age in people:
        |     print("%s is %d years old" % (name, age))
        |     # bob is 25 years old
        |     # john is 22 years old
        |     # ...

section.slide
    h2 | <em>for</em> като в C
    pre.prettyprint
        | for i in range(0, 20):
        |     print(i)
        |     # 0 1 2 3 4 5 6 .. 19

        | for i in range(0, 20, 3):
        |     print(i)
        |     # 0 3 6 9 12 15 18

section.slide
    h2 | <em>break</em> и <em>continue</em>
    ul
        li |  Работят както очаквате в <em>for</em> и <em>while</em>.
        li |  Афектират само най-вътрешния цикъл.

section.slide
    h2 | <em>switch</em>/<em>case</em>
    h3 | Няма.


section.slide
    h2 | Функции
    pre.prettyprint
        | def say_hello(name, from):
        |     return "Hello, %s! -- %s" % (name, from)
    ul
        li |  Функцията приема аргументи
        li |  Функцията може да върне нещо с return, иначе автоматично се връща None
        li |  Както очакваме, не се описват типовете на аргументите, нито типа на резултата
        li |  Имената

section.slide
    h2 | Аргументи на функции
    ul
        li |  Аргументи по подразбиране
    pre.prettyprint
        | def multiply(a, b = 2):
        |     return a * b

        | multiply(5) # 10
        | multiply(5, 10) # 50

        | def is_pythagorean(a = 2, b = 3, c = 4):
        |     return a * a + b * b == c * c

        | is_pythagorean(b = 5) # a = 2, c = 4
        | is_pythagorean(1, c = 3) # a = 1, b = 3

section.slide
    h2 | Променливи аргументи
    ul
        li |  Функциите могат да приемат произволен брой аргументи
        li |  Позиционните аргументи (тези без име) отиват в tuple <em>args</em>
        li |  Именованите аргументи отиват в <em>dict</em> <em>kwargs</em>
        li |  Имената <em>args</em> и <em>kwargs</em> могат да се променят, но това е конвенция, която не трябва да нарушавате
    pre.prettyprint
        | def varfunc(some_arg, *args, **kwargs):
        |     ...

        | varfunc('hello', 1,2,3, name = 'Bob', age = 12)
        |     # some_arg == 'hello'
        |     # args = (1,2,3)
        |     # kwargs = {'name': 'Bob', 'age': 12}

