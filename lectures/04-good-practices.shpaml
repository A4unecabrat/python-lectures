section.slide
    h2 | Писането на код като работа
    p
        | Когато пишете код, рядко го правите самоцелно. Вместо
        | това, вие опитвате се да решите някакъв реален проблем със собствена
        | логика, терминология и особености. Винаги когато пишете код трябва
        | да се стараете той да отразява много добре този проблем - това
        | го прави много по-четим, по-лесен за поддръжка и по-разбираем
        | от външни хора. Още повече, така вие ясно показвате намерението
        | което вашия код има, вместо да карате читателя да задълбава в
        | особенностите на вашата реализация.
section.slide
    h2 | Първо правило: Добри имена на променливи
    p
        | Променливите обикновенно отговарят за съществуващи
        | обекти/концепции в реалния проблем, който
        | решавате. Това ги прави идеални за комуникиране
        | на идеята на кода. За целта, обаче, се налага
        | да избирате смислени имена.
    ul
        li.slide | Използвайте смислени имена, които да показват ясно и недвусмислено за какво служи променливата
        li.slide | Спазвайте конвенция в именуването на нещата
        li.slide | Избягвайте думи, в които лесно се допускат правописни грешки
        li.slide | Избягвайте криптични съкращения или дълги имена - numberOfPeopleOnTheUsOlympicTeam, npot, teamMemberCount
        li.slide | Избягвайте като цяло безсмислени имена - thing, stuff, foo
        li.slide | Бъдете консистенти в наименоването на променливите - без shipsCount и numDocks в една програма.
        li.slide | Не използвайте една променлива два пъти за едни и същи неща.
section.slide
    h2 | Типична грешка
    pre.prettyprint
        | # Грешно
        | temp = sqrt(b ** 2 - 4 * a * c)
        | x1 = (-b + temp) / (2 * a)
        | x2 = (-b - temp) / (2 * a)

        | # По-правилно
        | discriminant = sqrt(b ** 2 - 4 * a * c)
        | x1 = (-b + discriminant) / (2 * a)
        | x2 = (-b - discriminant) / (2 * a)
section.slide
    h2 | Лоши имена
    pre.prettyprint
        | old = read_old()
        | tpl = get_values("c:/")
        | tup = {}
        | for t in tpl:
        |     if old[t] != tpl[t]: continue
        |     tup.update({t:tpl[t]})

        | show(tup)
        | save(tpl)
section.slide
    h2 | Добри имена
    pre.prettyprint
        | old_hashsums = read_cached_hashsums()
        | new_hashsums = find_hashsums('c:/')

        | changed_files = {}
        | for filename in old_hashsums:
        |     if old_hashsums[filename] != new_hashsums[filename]:
        |         changed_files[filename] = new_hashsums[filename]

        | report_changes(changed_files)
        | save_hashsums(new_hashsums)
section.slide
    h2 | Функция/Метод &gt; Блок с коментар
    p
        | Функциите са едно от най-често използваните
        | средства в програмирането. И все пак, причините за които има смисъл да създавате функция са.
    ul
        li.slide | Опростяване на кода.
        li.slide | Избягване на повтаряне на код.
        li.slide | Скриване на последователни действия.
        li.slide | Разширяемост.
        li.slide | За по-гъвкаво наследяване.
        li.slide | Изолиране на сложността.
        li.slide | Скриване на имплементационни детайли.
        li.slide | Като цяло: за създаване на абстракция.
section.slide
    h2 | Именуване на функции
    p | При именуване на рутини се съобразявайте внимателно със следните неща.
    ul
        li.slide | Да обяснява всичко което функцията прави
        li.slide | Избягвайте безсмислени и размити имена - doStuff(), generateData(), processInput().
        li.slide | Не различавайте две рутини само по число - wait2() и wait3().
        li.slide | Ако функцията връща стойност, кръстете я така че да описва връщаната стойност
        li.slide | Ако функцията е „процедура“, използвайте глагол в името й, който да описва действието й.
        li.slide | Използвайте противоположни имена - add/remove, open/close, get/set - консистентно.
section.slide
    h2 | Кохезия
    p
        | „Кохезията“ на една рутина смътно описва
        | действието й. Като говорим за „добра кохезия“
        | имаме предвид, че една рутина прави едно
        | единствено нещо и го прави добре. Най-силния вид „кохезия“ е функционалната.
section.slide
    h2 | Приемливи видове кохезия
    ul
        li.slide | Последователна кохезия - рутината капсулира няколко действия, които трябва да се направят последователно.
        li.slide | Комуникационна кохезия - рутината извършва няколко различни операции над едни и същи данни
        li.slide | Времева козехия - рутината извършва няколко действия, които трябва да станат едновременно - Startup(), Shutdown()
section.slide
    h2 | Неприемливи видове кохезия
    ul
        li.slide | Процедурна - когато рутината е създадена само защото това отговаря на последователността в която потребителя извършва действията.
        li.slide | Логическа - поведението на рутината зависи силно от стойността на някой параметър.
        li.slide | Случайна - когато действията в рутината не са особено свързани.
section.slide
    h2 | Аргументи на функциите
    ul
        li.slide | Действието на една рутина не трябва да зависи от стойностите на неин аргумент.
        li.slide | Старайте се да не ползвате повече от 7 (седем) аргумента в една рутина
        li.slide | Когато извиквате рутина с много аргументи, хубаво е да ползвате възможността на Python да предава аргументите наименовано.
        li.slide | Не променяйте състоянието на параметрите на функциите, ако може да го избегнете.
        li.slide | Ако ползвате параметри за изход, тогава избягвайте да ги ползвате и като входни.
        li.slide | Ако евентуално имате нужда от параметри за вход, вход-изход и изход, подреждайте ги консистентно в програмата си.
section.slide
    h2 | Не ползвайте глобални променливи
    p
        Когато пишете функции, не ползвайте глобални променливи. Ама въобще.
        Най-честия случай на неправилно ползване на глобавни променливи е когато се употребяват за комуникация между функции.
        Никога не правете това. В рядките случаи, в които имате нужда от „глобални“ обекти правете Singleton-и или thread.local-и.
section.slide
    h2 | Не ползвайте goto
    p | В Python няма goto. Ако случайно пишете на друг език, в който има goto, това правило остава - не ползвайте goto.
section.slide
    h2 | Не използвайте глупави низове в съобщенията за грешка
section.slide
    h2 | Състоянието е зло
    p | Като Дарт Вейдър, само дето накрая убива Люк, а не императора.
section.slide
    h2 | Еквивалентност
    ul
        li.slide | Observational equivalence
        li.slide | Behavior equivalence
    p | Имате два обекта. Те са равни ако…
section.slide
    h2 | Observational equivalence
    p | …с произволна поредица от observer методи не може да разберете дали те са различни или не.
section.slide
    h2 | Behavioral equivalence
    p | …с произволна поредица от observer-и и мутатори не може да разберете дали те са различни или не.
section.slide
    h2 | Design by Contract
    p | За всеки метод се дефинира следното:
    ul
       li.slide | Предусловие (precondition) - условие, което трябва да бъде изпълнено за да може клиентът да извика този метод
       li.slide | Постусловие (postcondition) - условие, гарантирано да бъде изпълнено след приключването на метода
       li.slide | Инвариант (invariant) - условие, което трябва да бъде изпълнено по време на изпълнение на метода
section.slide
    h2 | Наследяването е зло
    ul
        li.slide | Като състоянието. Унищожава планети.
        li.slide | Композицията е по-яка.
        li.slide | Не ни вярвате?
section.slide
    h2 | Кой кого?
    pre.prettyprint
        | class Rectangle:
        |         def a(self): ...
        |         def b(self): ...
        |         def setA(self, a): ...
        |         def setB(self, b): ...

        | class Square:
        |         def a(self): ...
        |         def setSide(self, side): ...
section.slide
    h2 | Liskov's Substitution Principle
    p | Клас Б може да наследи от клас А, само ако на всички места на които може да използвате инстанция на А може да използвате инстанция на Б.
section.slide
    h2 | Liskov's Substitution Principle (2)
    p | В термините на Design by Contract Б може да наследи А ако:
    ul
        li.slide | Дефинира толкова или по-малко строги предусловия от А
        li.slide | Дефинира толкова или по-строги постусловия от А
        li.slide | Запазва инвариантите на А
section.slide
    h2 | Design Patterns
    p | The second coming of Jesus.
section.slide
    h2 | Version Control System
    p
        Системите за контрол на версиите не са добра практика.
        Те са задължителна практика!
section.slide
    h2 | Колко от вас са чували за тези?
    ul
        li.slide | CVS
        li.slide | SVN
        li.slide | Bazaar
        li.slide | Perforce
        li.slide | Microsoft SourceSafe (rofl)
        li.slide | Mercurial
        li.slide | strong | Git
section.slide
    h2 | За чий ни е контрол на версиите?
section.slide
    h2 | История - Пълна видимост над промените
    ul
        li.slide | Кое и кога е променено?
        li.slide | И най-вече...кой?
        li.slide | Понякога и защо?
section.slide
    h2 | Бранчове
    ul
        li.slide | Пясъчник(sandbox) за промени
        li.slide | Пазим си неготовите парчета код
        li.slide | Бързо switch-ваме между тях
section.slide
    h2 | Пазарът и катедралата
section.slide
    h2 | Git and GitHub
    p | Линукс е второто най-добро нещо, създадено от Линус Торвалдс
    ul
        li.slide | a href='http:/git-scm.com' | http://git-scm.com/
        li.slide | a href='http:/github.com' | http://github.com/
