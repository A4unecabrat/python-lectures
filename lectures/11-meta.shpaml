section.slide
    h2 | С 22 думи
    blockquote:
        Metaprogramming is the language feature that helps you write code that you won't be able to understand once the cocaine wears off.
    attr | <a href="https://twitter.com/bos31337/status/13349058839">twitter.com/bos31337</a>

section.slide
    h2 | Data Model (aka MOP)
    blockquote:
        Objects are Python’s abstraction for data. All data in a Python program is represented by objects or by relations between objects.

section.slide
    h2 | Обектите отвътре
    pre.prettyprint:
        class Person:
            def __init__(self, name):
                self.name = name

            def say_hi(self):
                print("Hi, I am", self.name)

section.slide
    h2 | Обектите отвътре
    p | Обектите отвътре са просто речници. Всеки обект си има специален речник който пази атрибутите му:

    pre.prettyprint:
        >>> goshko = Person('Gospodin Goshko')
        >>> hasattr(goshko, '__dict__')
        True
        >>> goshko.__dict__
        {'name': 'Gospodin Goshko'}

        >>> goshko.__dict__['profession'] = 'Hacker'
        >>> goshko.profession
        'Hacker'
        >>> goshko.__dict__
        {'profession': 'Hacker', 'name': 'Commander Gosh'}

        >>> goshko.__dict__.clear()
        >>> goshko.name
        Traceback (most recent call last):
          File "<stdin>", line 1, in <module>
        AttributeError: 'Person' object has no attribute 'name'

section.slide
    h2 | Класът Ninja
    pre.prettyprint:
        class Ninja:
            def __init__(self, name, target):
                self.name = name
                self.target = target

            def say_hi(self):
                print("Ninja!")

            def kill_target(self):
                print("Slash ", self.target)

section.slide
    h2 | Класът е специален атрибут на обекта
    pre.prettyprint:
        >>> goshko = Person('Gospodin Goshko')
        >>> goshko.say_hi()
        Hi, I am Gospodin Goshko
        >>> type(goshko)
        &lt;class '__main__.Person'&gt;
        >>> goshko.__class__
        &lt;class '__main__.Person'&gt;

        >>> goshko.__class__ = Ninja
        >>> type(goshko)
        <class '__main__.Ninja'>
        >>> goshko.say_hi()
        Ninja!
        >>> goshko.kill_target()
        Traceback (most recent call last):
          File "<stdin>", line 1, in <module>
          File "<stdin>", line 4, in kill_target
        AttributeError: 'Ninja' object has no attribute 'target'

section.slide
    h2 | Конструиранйе
    pre.prettyprint:
        object.__new__(cls[, ...])

        object.__init__(self[, ...])

section.slide
    h2 | __new__
    p | <em>__new__</em> е истинският конструктор на вашите обекти. <em>__init__</em> е само инициализатор:
    pre.prettyprint:
        class Vector(tuple):

            def __new__(klass, x, y):
                return tuple.__new__(klass, (x, y))

            def __add__(self, other):
                if not isinstance(other, Vector):
                    return NotImplemented
                return Vector(self[0] + other[0], self[1] + other[1])

section.slide
    h2 | Достъп на атрибути
    pre.prettyprint:
        object.__getattr__(self, name)

        object.__setattr__(self, name, value)

        object.__delattr__(self, name)

        object.__dir__(self)

section.slide
    h2 | Още достъп на атрибути
    pre.prettyprint:
        object.__getattribute__(self, name)

    p | При извикване на <em>obj.name</em>:
    ol
      li | проверява се дали <em>name</em> не присъства в <em>obj.__dict__</em>. Ако да - връща се тази стойност
      li | ако не - проверява се дали класът, <em>obj.__class__</em> има такъв атрибут в своя <em>__dict__</em>. Ако да, и той няма метод <em>__get__</em>, се връща
      li | ако атрибута на <em>obj.__dict__</em> има метод <em>__get__</em>, то методът <em>obj.__dict__.__get__</em> се изпълнява със съответните оргументи


section.slide
    h2 | Дескриптори
    pre.prettyprint:
        object.__get__(self, instance, owner)

        object.__set__(self, instance, value)

        object.__delete__(self, instance)

section.slide
    h2 | Извикване на дескриптори
    pre.prettyprint:
        # direct call
        x.__get__(a)

        # instance binding on a.x
        type(a).__dict__['x'].__get__(a,  type(a))

        # class binding on A.x
        A.__dict__['x'].__get__(None,  A)

        # super binding
        # super black magic

section.slide
    h2 | До тук
    p | Метаобектният протокол на Python
    ul
        li | __dict__
        li | __new__/__init__
        li | __getattribute__/__setattr__
        li | __get__/__set__/__del__

section.slide
    h2 | Tim Peters on metaclasses
    blockquote:
        Metaclasses are deeper magic than 99% of the users should ever worry about. If you wonder whether you need them, you don't (the people who actually need them know with certainty that they need them, and don't need an explanation about why).
    attr | &mdash; Tim Peters

section.slide
    h2 | Метакласове
    ul
        li | всичко в Пайтън е обект, включително и класовете
        li | всеки обект е инстанция на някакъв клас, включително и класовете
        li | класовете на класовете си имат специално име - метакласове
        li | има един стандартен метаклас - <em>type</em>

section.slide
    h2 | Забележка
    p | В Пайтън <em>type</em> значи няколко неща:
    ul
        li | с един аргумент <em>type(x)</em> връща типа на x
        li | без аргументи е просто класът <em>type</em>
        li | с три аргумента се конструира инстанция на <em>type</em>

section.slide
    h2 | Type "help"
    pre.prettyprint:
        # обекти
        >>> type(42), type("42"), type(object())
        (<class 'int'>, <class 'str'>, <class 'object'>)

        # типове
        >>> type(int), type(str), type(object)
        (<class 'type'>, <class 'type'>, <class 'type'>)

        # връзката
        >>> issubclass(int, type)
        False
        >>> isinstance(int, type)
        True

section.slide
    h2 | Help more
    pre.prettyprint:
        >>> issubclass(object, type)
        False
        >>> isinstance(object, type)
        True

        >>> issubclass(type, object)
        True
        >>> issubclass(object, type)
        False

        >>> isinstance(type, object)
        True # естествено
        >>> isinstance(type, type)
        True # втф?!

section.slide
    h2 | Типът на всички типове
    p | <em>type</em> разбира се. Инстанции на type създавате с:
    pre.prettyprint:
        type(name, bases, dict)

    p | Какво е инстанция на <em>type</em> - просто клас.

    ul
        li | <em>name</em>  - име на новия клас
        li | <em>bases</em> - <em>tuple</em> с базовите му класове
        li | <em>dict</em>  - речник с полетата му (не по-различно от __dict__)

section.slide
    h2 | Нинджа
    pre.prettyprint:
        def човек_инициализирай(self, name):
            self.name = name

        def човек_кажи_здрасти(self):
            print("Здрасти, аз съм", self.name)

        Човек = type( 'Човек', (), {
                    '__init__' : човек_инициализирай,
                    'кажи_здрасти': човек_кажи_здрасти }
                )

        Човек('¡Испанска нинджа!').кажи_здрасти()

section.slide
    h2 | Как указваме метаклас
    pre.prettyprint:
        class Foo(A, B, C, metaclass=Bar):
            pass

section.slide
    h2 | Просто синтактична захар
    pre.prettyprint:
        class Foo(A, B, C, metaclass=Bar):
            x = 1
            y = 2

        # е захар за

        Foo = Bar('Foo', (A, B, C), {'x':1, 'y':2})


section.slide
    h2 | Простичко
    pre.prettyprint:
        class metacls(type):
            def __new__(mcs, name, bases, dict):
                dict['foo'] = 'metacls was here'
                return type.__new__(mcs, name, bases, dict)

section.slide
    h2 | Един пример
    pre.prettyprint:
        class R(metaclass=ReverseNames):
            def forward(self):
                print('forward')
    pre.prettyprint:
        >>> r = R()
        >>> r.forward()
        Traceback (most recent call last):
          File "<stdin>", line 1, in <module>
        AttributeError: 'R' object has no attribute 'forward'
        >>> r.drawrof()
        forward

section.slide
    h2 | Как?
    pre.prettyprint:
        class ReverseNames(type):
            def __new__(klass, name, bases, _dict):
                reversed = [(k[::-1], v) for k, v in _dict.items()]
                return type.__new__(klass, name, bases, dict(reversed))


section.slide
    h2 | Атрибути в метакласа
    pre.prettyprint:
        class Meta(type):
            def bar(self):
                print(self)
        class Foo(metaclass=Meta):
            pass
    pre.prettyprint:
        >>> f = Foo()
        >>> f.bar()
        Traceback (most recent call last):
          File "<stdin>", line 1, in <module>
        AttributeError: 'Foo' object has no attribute 'bar'

        >>> Foo.bar()
        <class '__main__.Foo'>

        >>> Meta.bar()
        # ???

section.slide
    h2 | Себична Нинджа
    pre.prettyprint:
        class Person(metaclass=selfless):
            def __init__(name):
                self.name = name

            def say_hi():
                print("Hi, I am", self.name)

        Person("忍者").say_hi()

section.slide
    h2 | Себичен питон
    pre.prettyprint:
        def without_ego(func):
            def wrapped(self, *args, **kwargs):
                old_self = func.__globals__.get('self')
                func.__globals__['self'] = self
                result = func(*args, **kwargs)
                func.__globals__['self'] = old_self
                return result
            wrapped.__name__ = func.__name__
            return wrapped

        class selfless(type):
            def __new__(cls, name, bases, attrs):
                for key, value in attrs.items():
                    if not hasattr(value, '__call__'): continue
                    attrs[key] = without_ego(value)
                return type.__new__(cls, name, bases, attrs)

section.slide
    h2 | 2eval|!2eval?

    p | Не ползвайте <em>eval()</em>.

section.slide
    h2 | Връзки
    ul
        li | <a href="http://docs.python.org/py3k/reference/datamodel.html">Python Data Model</a>
        li | <a href="http://docs.python.org/py3k/reference/datamodel.html#customizing-class-creation">Customizing class creation</a>
