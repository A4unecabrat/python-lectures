section.slide
    h2 | Защо искаме да правим игри?
    ul
        li | Забавни са
        li | Предлагат ни изцяло нов начин на мислене
section.slide
    h2 | Колко точно различно е?
    ul
        li | Дребните детайли са критични
        li | Зависите от ресурсите на потребителската машина
        li | Физика, Изкуство, Музика, Математика...
section.slide
    h2 | Основните ни занимания
    ul
        li | Показваме неща на екрана
        li | Обработваме потребителски вход
        li | Механика
        li | Звуци и музика
        li | Завършена архитектура на една игра
section.slide
    h2 | Показваме неща на екрана
    ul
        li | Отваряме прозорец
        li | Чертаем разни неща
        li | Местим вече налични такива
        li | И за всичко това ще ни трябват event-и
section.slide
    h2 | Безкрайният цикъл
    p | Цялата ни игра е един безкраен цикъл, в който обработваме event-и
    pre.prettyprint
        |import pygame

        |pygame.init()
        |screen = pygame.display.set_mode((640, 480))

        |running = True
        |while running:
        |    for event in pygame.event.get():
        |        if event.type == pygame.QUIT:
        |            running = False
        |        if event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
        |            running = False
section.slide
    h2 | Безкраен цикъл <em>done right</em>
    pre.prettyprint
        | import pygame

        | class Game(object):
        |     def main(self, screen):
        |         while 1:
        |             for event in pygame.event.get():
        |                 if event.type == pygame.QUIT:
        |                     return
        |                 if event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
        |                     return

        | if __name__ == '__main__':
        |     pygame.init()
        |     screen = pygame.display.set_mode((640, 480))
        |     Game().main(screen)
section.slide
    h2 | Чертаене
    ul
        li | Координатна система
        li | <em>fill &amp; blit</em>
        li | <em>flip</em>
        li | <em>pygame.time.Clock</em>
        li | Scene construction
section.slide
    h2 | FPS
    p | Различни машини - различни възможности.
    ul
        li | <em>pygame.time.Clock</em>
    pre.prettyprint
        |while 1:
        |    clock.tick(30)

        |    for event in pygame.event.get():
        |        if event.type == pygame.QUIT:
        |            return
        |        if event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
        |            return

        |    screen.fill((200, 200, 200))
        |    screen.blit(image, (320, 240))
        |    pygame.display.flip()
section.slide
    h2 | Анимации
    p | Със всяка итерация променяме координатите на нещото, което се "движи"
    p | и всеки път подаваме новите на <em>screen.blit</em>:
    pre.prettyprint | screen.blit(image, (x, y))

section.slide
    h2 | User Input
    ul
        li | Events
        li | State dictionary
    pre.prettyprint
        | key = pygame.key.get_pressed()
        | if key[pygame.K_LEFT]:
        |     image_x -= 10
        | if key[pygame.K_RIGHT]:
        |     image_x += 10
        | if key[pygame.K_UP]:
        |     image_y -= 10
        | if key[pygame.K_DOWN]:
        |     image_y += 10
section.slide
    h2 | Sprites
    p | Двуизмерна картинка или анимация, интегрирана в някакво пространство
    pre.prettyprint
        | class Player(pygame.sprite.Sprite):
        |     def __init__(self, *groups):
        |         super(Player, self).__init__(*groups)
        |         self.image = pygame.image.load('player.png')
        |         self.rect = pygame.rect.Rect((320, 240), self.image.get_size())

        |     def update(self):
        |         key = pygame.key.get_pressed()
        |         if key[pygame.K_LEFT]:
        |             self.rect.x -= 10
        |         if key[pygame.K_RIGHT]:
        |             self.rect.x += 10
        |         if key[pygame.K_UP]:
        |             self.rect.y -= 10
        |         if key[pygame.K_DOWN]:
        |             self.rect.y += 10
section.slide
    h2 | Групи от спрайтове
    p | В общия случай го раздаваме с десетки/стотици спрайтове.
    p | Не искаме да се молим на всеки един по отделно да се пречертае
    pre.prettyprint
        | class Game(object):
        |     def main(self, screen):
        |         clock = pygame.time.Clock()

        |         sprites = pygame.sprite.Group()
        |         self.player = Player(sprites)

        |         while 1:
        |             clock.tick(30)

        |             for event in pygame.event.get():
        |                 if event.type == pygame.QUIT:
        |                     return
        |                 if event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
        |                     return

        |             sprites.update()
        |             screen.fill((200, 200, 200))
        |             sprites.draw(screen)
        |             pygame.display.flip()
section.slide
    h1 | Smoother!
section.slide
    h2 | Малко по-приятна сцена
    p | <em>screen.fill</em> е полезно, но изключително куцо
    p | Би било далеч по-приятно да имаме някакъв красив фон...като небе примерно:
    pre.prettyprint
        | def main(self, screen):
        |     clock = pygame.time.Clock()

        |     background = pygame.image.load('background.png')
        |     sprites = pygame.sprite.Group()
        |     self.player = Player(sprites)

        |     while 1:
        |         dt = clock.tick(30)
        |         for event in pygame.event.get():
        |         [....]

        |         sprites.update(dt / 1000.)
        |         screen.blit(background, (0, 0))
        |         sprites.draw(screen)
        |         pygame.display.flip()

section.slide
    h1 | The real deal!
section.slide
    h2 | Gameplay Mechanics
    ul
        li | Player Controls
        li | Timed rules - кога се появяват обекти, как се движат по полето и кога са излишни
        li | Интеракция с другите обекти(collision detections)
        li | Строго следене за важните събития
section.slide
    h2 | Collision detection
    p | 4 основни подхода:
    ul
        li | Axis-Aligned Bounding Box
        li | Circle-Circle
        li | HashMap
        li | Pixel-Perfect
section.slide
    h2 | Препядствия
    p | Ще добавим стени, че да не ни бяга човечето, също биха били полезни:
    pre.prettyprint
        | self.walls = pygame.sprite.Group()
        | block = pygame.image.load('block.png')
        | for x in range(0, 640, 32):
        |     for y in range(0, 480, 32):
        |         if x in (0, 640-32) or y in (0, 480-32):
        |             wall = pygame.sprite.Sprite(self.walls)
        |             wall.image = block
        |             wall.rect = pygame.rect.Rect((x, y), block.get_size())
        | sprites.add(self.walls)
section.slide
    h2 | Сблъсъци с препядствията
    pre.prettyprint
        | last = self.rect.copy()
        | for cell in pygame.sprite.spritecollide(self, game.walls, dokill=False):
        |     self.rect = last
section.slide
    h2 | Прецизни сблъсъци
    pre.prettyprint
        | new = self.rect
        | for cell in pygame.sprite.spritecollide(self, game.walls, False):
        |     cell = cell.rect
        |     if last.right <= cell.left and new.right > cell.left:
        |         new.right = cell.left
        |     if last.left >= cell.right and new.left < cell.right:
        |         new.left = cell.right
        |     if last.bottom <= cell.top and new.bottom > cell.top:
        |         new.bottom = cell.top
        |     if last.top >= cell.bottom and new.top < cell.bottom:
        |         new.top = cell.bottom
section.slide
    h2 | И още...
    ul
        li | http://pygame.org/
        li | http://pyvideo.org/video/615/introduction-to-game-development

