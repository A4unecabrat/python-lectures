
section.slide
    h2 | Типове
    ul 
        li | int
        li | str
        li | bool
        li | float
        li | none
        li | object
        li | callable
        li | type(something)

section.slide
    h2 | Списъци (<em>list</em>)

    pre.prettyprint:
        >>> x = [1, 2, 3]
        >>> x.append(5)
        [1, 2, 3, 5]
        >>> del x[2]
        >>> len(x)
        >>> 2 in x # True

section.slide
    h2 | Речници (<em>dict</em>)
    
    pre.prettyprint:
        >>> x = {'a': 10, 'b': 20}
        >>> x['c'] = 40
        >>> 'c' in x # True
        >>> 40 in x # False
        >>> del x['c']
        >>> x.update({'z': 1000, 'b': 21})
        >>> x
        {'a': 10, 'b': 21, 'c': 40, 'z': 1000}

section.slide
    h2 | Сетове (<em>set</em>)
    
    pre.prettyprint:
        >>> x = {1, 5, 'Hello', False}
        >>> x.add(4)
        >>> x.add(5)
        >>> x.remove('Hello')
        >>> x
        {1, 5, False, 4}

section.slide
    h2 | Tuples
    pre.prettyprint:
        >>> x = (1,2,3)
        >>> x[1]
        2

    p | и толкоз - не могат да се променят

section.slide
    h2 | Mutable vs immutable
    ul
        li | Immutable са стойностите, които не могат да бъдат променяни.
    pre.prettyprint:
        а = 5
        а += 2 # 7
    p | Този код не променя стойноста на 5, а кара <em>а</em> да сочи към друга стойност (7). Числата са immutable.
    pre.prettyprint:
        а = [1,2,3]
        a.append(4)
    p | Този код променя списъка, към който сочи <em>a</em>. Списъците са mutable.
    ul
        li |  Immutable са числа, низове, tuples, True, False, None, дата/час (datetime), класове и функции.
        li |  Всичко останало е mutable.
        li |  Като ключ на <em>dict</em> или елемент на <em>set</em> могат да се ползват само immutable стойности.


section.slide 
    h2 | Контролни структури
    pre.prettyprint:
        if a > 5:
            # do something
        elif a > 2:
            # do other
        else:
            # do third thing

        for e in my_list:
            print(e)

        for i in range(0, 100):
            print(i ** i)

        while a > 5:
            a -= 1
            print("a is now " + a)

section.slide
    h2 | Функции
    pre.prettyprint:
        def my_func(a, b, *args, **kwargs):
            print(type(args)) # list
            print(type(kwargs)) # dict
        my_func(*[1,2,3])

section.slide
    h2 | Анонимни фуннкции
    pre.prettyprint:
        >>> operation = lambda x, y: x * y
        >>> print(operation(6, 7))
        42

section.slide
    h2 | map и filter
    pre.prettyprint:
        >>> list(map(lambda x: x ** 2, range(1, 10)))
        [1, 4, 9, 16, 25, 36, 49, 64, 81]

        >>> list(filter(lambda x: x % 2, range(1, 10)))
        [1, 3, 5, 7, 9]

section.slide
    h2 | list comprehensions
    p | [<i>израз</i> for <i>променлива</i> in <i>поредица</i> if <i>условие</i>]

    pre.prettyprint:
        >>> [x * x for x in range(0, 10) if x % 2]
        [1, 9, 25, 49, 81]


    pre.prettyprint:
        >>> nums = range(0, 10)
        >>> [(x, y) for x in nums for y in nums if (x + y) == 13]
        [(4, 9), (5, 8), (6, 7), (7, 6), (8, 5), (9, 4)]

section.slide
    h2 | set и dict comprehensions
    pre.prettyprint:
        >>> {x % 8 for x in range(0, 20) if (x % 2) == 0}
        {0, 2, 4, 6}

        >>> {x: x**2 for x in range(0, 5)}
        {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}

section.slide
    h2 | Unit testing
    pre.prettyprint:
        class MyUnitTest(unittest.TestCase):
            def test_first_feature(self):
                # създаваме среда за теста
                self.assertTrue(<i>нещо</i>)
                self.assertEqual(<i>едно</i>, <i>друго</i>)
                self.failIf(<i>нещо, което трябва да е False</i>)

            def test_second_feature(self):
                ...

        if __name__ == "__main__":
            unittest.main()

section.slide
    h2 | Видове тестове
    ul
        li.slide | <strong>Unit tests</strong> - проверяват дали дадено парче код/клас работи правилно в изолация
        li.slide | <strong>Integration tests</strong> - проверяват дали няколко модула си общуват правилно
        li.slide | <strong>Functional tests</strong> - проверяват дали крайната функционалност е както се очаква


section.slide
    h2 | Test-Driven Developmnt 
    ul
        li.slide | Първо пишем тест, после код, който да удовлетвори теста
        li.slide | Подход за писане на код
        li.slide | Дизайна е базиран върху обратна връзка, не гадаене
        li.slide | Спестява излишен код -- пишете само каквото ви трябва
        li.slide | Спестява излишна функционалност
        li.slide | Продуктивност!

section.slide
    h2 | Изключения
    p | Всички класове на изключения наследяват <em>Exception</em> и се казват <em>НещоError</em>
    pre.prettyprint:
        def myfunc():
            raise DairyException("OUT OF CHEESE ERROR.")  

        try:
            myfunc()
        catch DairyException e:
            print("Seomthing went wrong: " + e)
        finally:
            print("Program finished")
        
section.slide
    h2 | Генератори (<em>yield</em>)
    p | Функция, която се държи като итератор

    pre.prettyprint:
        def primes():
            number = 2
            while True:
                if all([number % divisor for divisor in range(2, number)]):
                    yield number
                number += 1

    
section.slide
    h2 | Итератори
    pre.prettyprint:
        iterator = iter([1,2,3])
        while True:
            try:
                x = next(iterator)
                print(x)
            catch StopIteration:
                break

section.slide
    h2 | Класове
    pre.prettyprint:
        class Accumulator(SomeBaseClass):
            def __init__(self, value):
                self.value = value

            def get_value(self):
                return self.value

            def increment(self, a = 1):
                self.value += a

section.slide
    h2 | Статични методи
    pre.prettyprint:
        class Person:
            people = []

            @staticmethod
            def register(name):
                Person.people.append(name)
                print(len(Person.people), "people are registered now")

        >>> Person.register("Mityo the Python")
        1 people are registered now
        >>> Person.register("Pooh")
        2 people are registered now


section.slide
    h2 | Класови методи
    pre.prettyprint:
        class Something:
            @classmethod
            def greet(cls, someone):
                print(someone, "was greeted from", cls)

        >>> Something.greet("Mityo")
        Mityo was greeted from &lt;class '__main__.Something'&gt;

section.slide
    h2 | Специални методи
    ul
        li | __repr__(self)
        li | __str__(self)
        li | __doc__
        li | __dir__(self)

section.slide
    h2 | Специални методи
    ul
        li | __getattribute__(self, name)
        li | __getattr__(self, name)
        li | __setattr__(self, name, value)
        li | __delattr__(self, name)
        li | __dir__(self)


section.slide
    h2 | Декоратори
    pre.prettyprint:
        def memoize(func):
            memory = {}
            def memoized(*args):
                if args in memory:
                    return memory[args]
                result = func(*args)
                memory[args] = result
                return result
            return memoized

section.slide
    h2 | Декоратори в действие
    pre.prettyprint:
        @memoized
        def fibonacci(x):
            if x in [0,1]:
                return 1
            return fibonacci(x-1) + fibonacci(x-2)

section.slide
    h2 |  Декоратори с аргументи
    pre.prettyprint:
        def accepts(*types):
          def accepter(f):
            def decorated(*args):
              for (i, (arg, t)) in enumerate(zip(args, types)):
                if not isinstance(arg, t):
                  raise TypeError("""Argument #{0} of '{1}' should \
                       have been of type {2}".format(i,
                                           f.__name__,
                                           t.__name__))
                return f(*args)
              return decorated

section.slide
    h2 | 
