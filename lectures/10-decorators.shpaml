section.slide
    h2 | Появяваха се от време на време...
    pre.prettyprint:
        | @staticmethod
        | def register(name)
        |     Person.people.append(name)
        |     print(len(Person.people), "people are registered now")
        | [...]
        | @classmethod
        | def greet(cls, someone)
        |     print(someone, "was greeted from", cls)
section.slide
    h2 | Но преди това...
    ul
        li.slide
            Какво различава функцията от всеки друг обект?
            ul
                li.slide |  <em>__call__</em>
        li.slide
            Какви типове обекти може да връща една функция?
            ul
                li.slide | <em>всякакви</em>
    p.slide | Хм...защо тогава една функция да не връща друга?
section.slide
    h2 | Айде малко математика
    pre.prettyprint:
        | def fibonacci(x):
        |     if x in [0,1]:
        |         return 1
        |     return fibonacci(x-1) + fibonacci(x-2)
    p
        | Да де, ама е рекурсивна <br>
        | =&gt; при аргумент x &gt; 40 е изключително бавна <br>
        | Без значение колко пъти я извикваме с един и същи аргумент
    h2.slide | Как да минимизираме излишните сметки?
    ul
        li.slide | Голям dict() с първите стотина елемента е overkill
section.slide
    h2 | Повторението е баща на затъпяването
    p | Защо просто не се опитаме да си записваме вече пресмятаните стойности?
    pre.prettyprint:
        | if x not in memory:
        |     memory[x] = fibonacci(x)
        | print(memory[x])
    ul
        li.slide | Много яко, нали?
        li.slide | Ама какво се случва ако това го искаме на 10 места из кода ни?
        li.slide | ... или на сто?
section.slide
    h2 | Защо тогава една функция да не връща друга?
    p | Декоратори наричаме функциите f от вида:
    ul
        li | <strong>f(функция) -> функция</strong>
    p | Резултатът е нова функция, разширяваща функционалността на първата.
section.slide
    h2 | memoize()
    pre.prettyprint
        | def memoize(func):
        |     memory = {}
        |     def memoized(*args):
        |         if args in memory:
        |             return memory[args]
        |         result = func(*args)
        |         memory[args] = result
        |         return result
        |     return memoized
    h2 | Под дефиницията на fibonacci
    pre.prettyprint
        | fibonacci = memoize(fibonacci)
section.slide
    h2 | Лошият и грозният
    p | И все пак
    pre.prettyprint:
        | def fibonacci(x):
        |     if x in [0,1]:
        |         return 1
        |     return fibonacci(x-1) + fibonacci(x-2)

        | fibonacci = memoize(fibonacci)
    p | …е грозно. А и има шанс да не видите декоратора, понеже е отдолу.
section.slide
    h2 | Клинт Ийстууд
    pre.prettyprint
        | @memoized
        | def fibonacci(x):
        |     if x in [0,1]:
        |         return 1
        |     return fibonacci(x-1) + fibonacci(x-2)
section.slide
    h2 | Друг пример за декоратор
    pre.prettyprint
        | def notifyme(f):
        |     def logged(*args, **kwargs):
        |         print(f.__name__, ' called with', args, 'and', kwargs)
        |         return f(*args, **kwargs)
        |     return logged

        | @notifyme
        | def square(x):
        |     return x * x

        | res = square(25)
        | #square was called with (25,) and {}.
section.slide
    h2 | Няколко декоратора на една функция
    pre.prettyprint
        | class Mityo:
        |     @staticmethod
        |     @notifyme
        |     def work(): pass

        | Mityo.work()
        | work was called with () and {}
    p | Първо се извикват най-вътрешните декоратори.
section.slide
    h2 | Прави същото като:
    pre.prettyprint
        | def work(): pass
        | work = notifyme(work)
        | work = staticmethod(work)
    p | или:
    pre.prettyprint
        | work = staticmethod(notifyme(work))
    ul
        li.slide | Какво правим, ако искаме да му подаваме аргументи?
section.slide
    h2 | Динамични декоратори
    p | Декоратор, който приема параметри.
    pre.prettyprint
        | @memoize('/tmp/fibs')
        | def fibonacci(n):
        | [...]
    p | е равно на
    pre.prettyprint
        | def fibonacci(n):
        | [...]
        | f = memoize('/tmp/fibs')(fibonacci)
    p | Да не се бърка с
    pre.prettyprint | fibonacci = memoize('/tmp/fibs', fibonacci)
section.slide
    h2 | На лов за патици
    p | Всъщност, защо да не си направим следния декоратор:
    pre.prettyprint
        | @accepts(int, int)
        | def add(a, b):
        |     return a+b
    p | Превод на недекораторски:
    pre.prettyprint
        | add = accepts(int, int)(add)
section.slide
    h2 |  код &gt; думи
    pre.prettyprint
        | def accepts(*types):
        |   def accepter(f):
        |     def decorated(*args):
        |       for (i, (arg, t)) in enumerate(zip(args, types)):
        |         if not isinstance(arg, t):
        |           raise TypeError("""Argument #{0} of '{1}' should \
        |                have been of type {2}".format(i,
        |                                    f.__name__,
        |                                    t.__name__))
        |           #TODO: more complex checks
        |         return f(*args)
        |       return decorated
        |   return accepter
section.slide
    h2 | За патиците с любов
    p | duck typing е много важна част от философията на Python. @accepts е забавен пример и дори има някои употреби, но избягвайте да го ползвате масово. В повечето случаи губите, а не печелите. 
section.slide
    h2 | Полезни декоратори
    ul
        li | <em>classmethod</em> — прави метода класов (приема клас, а не обект като първи аргумент)
        li | <em>staticmethod</em> — прави метода статичен
        li.slide | <em>property</em>
section.slide
    h2 | @property
    pre.prettyprint
        | class Battery(object):
        |     def __init__(self):
        |         self._voltage = 100000

        |     @property
        |     def voltage(self):
        |         """Get the current voltage."""
        |         return self._voltage
    p | Това превръща voltage в getter към атрибут само за четене със същото име
section.slide
    h2 | @property си има и setter
    pre.prettyprint
        |   @voltage.setter
        |   def voltage(self, value):
        |       self._voltage = value
    ul
        li.slide | В този ред на мисли, си има и <em>deleter</em>
section.slide
    h2 | Meyer's substitution principle
    blockquote | Атрибутите на един обект трябва да бъдат достъпвани през хомогенна нотация, която не издава дали те се изчисляват или са записани. 

