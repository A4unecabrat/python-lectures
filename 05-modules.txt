Модули

23.03.2011 г.

== Въпрос (1) ==
{{{python
numbers = [1,2,3]
while True:
    number = next(numbers)
    print(number)
}}}
 * ((`TypeError: list object is not an iterator`))

== Въпрос (2) ==
{{{python
squares = map(lambda x: x*x, [0,1,2,3,4])
for x in squares:
    for y in squares:
        print(x, y)
}}}

== Въпрос 3 ==
{{{python
{42: x for x in [1,2,3]}
}}}

== Въпрос 4 ==
{{{python
def ones():
    while True:
        yield 1

twos = (2*x for x in ones())
twos = [2*x for x in ones()]
}}}

== Въпрос (5) ==
{{{python
def print_args(a, b, *c):
    print(a)
    print(b)
    print(c)

print_args(*range(4))
}}}

== Модули ==
 * ((Какво? Всеки `.py` файл е отделен модул))
 * ((Как? Имат собствен `namespace`))
 * ((Защо? Организация и преизползване на код))
 * ((Кога? Когато имаме няколко функции или класове, спадащи в обща категория.))

== Но преди това... ==
 * ((Знаем, че `python` кодът ни се компилира до `bytecode`))
 * ((Знаем, че това се случва ***само*** ако е нужно))
 * ((Знаем, че в общия случай се изпълнява компилираният код))
 * ((А знаем ли как се случва цялата тази магия?))

== .pyc ==
 * ((Кеш за компилирани `.py` файлове))
 * ((Ако извикаме `python spam.py`, той не се компилира))
 * ((***НЕ*** се изпълняват по-бързо от `.py`))
 * ((Зареждат се по-бързо))
 * ((От `Python 3.2` се пазят в `__pycache__/`))
 * ((`{името-на-файла}.cpython-{версия}.pyc`))

== Елементарен проблем ==
world.py:
{{{python
""" A module for playing with the world. """
def destroy():
    """Destroys the world."""
    print("The world was destroyed!")

def save(kind):
    """Saves a kind."""
    print("All the", kind, "were saved.")
}}}

== Елементарно решение ==
<em>women.py</em>:
{{{python
import world
world.save('women')
world.destroy()	
}}}
<em>beers.py</em>:
{{{python
import world
world.save('beers')
world.destroy()	
}}}

 * ((Използваме един и същи код много пъти (code reuse)))

== Атрибути ==
 * Обектите имат свързани с тях имена, наречени ***атрибути***, които се достъпват чрез оператора `.` (точка)
 * Нека разгледаме по-подробно `world.destroy()`
 * `destroy` е функция и е атрибут на обекта `world`, който пък е модул
{{{python
>>> world
&lt;module 'world' from 'world.py'&gt;
>>> world.destroy
&lt;function destroy at 0x7f172370b958&gt;
}}}

== Области от имена ==
 * В различни модули можем да имаме едни и същи имена
 * Всеки модул си има различен набор от имена
{{{python
import spam
import egg
def eat():
    print("What... more?")
spam.eat()
egg.eat()
eat()
}}}

== Търсене на атрибути ==

 * `answer = 42`
 * В този случай е ясно, че обектът зад името `answer` трябва да се търси по стандартния начин (в разните обхвати)
 * `universe.question = 6 * 9`
 * Името `question` не трябва да се търси в стандартните обхвати, а трябва да се търси в списъка с атрибути на обекта зад името `universe`
 * `universe.milkyway.earth.europe.bg.beautify()`

== Модули и обхвати ==l

 * Глобалните променливи са на практика модулни променливи. Те са глобални само в рамките на модула, в който се намират.
 * <em>beer.py</em>:
{{{python
bottles = 1
def drink_bottle():
    global bottles
    bottles += 1
}}}
 * <em>bottler.py</em>:
{{{python
import beer
bottles = 5
beer.drink_bottle()
print(bottles, beer.bottles)
}}}
 * ((Резултатът: `5 2`))

== Използване на модули &mdash; `import` ==
С конструкцията `import` можем да ползваме код от външни файлове.

Ето какво се случва, ако изпълним `import beer`:

 # ((Открива се файла, в който се намира модула))
 # ((Кодът се компилира до bytecode (ако е необходимо) ))
 # ((Кодът на модула се изпълнява (дефиниции на функции, друг код) ))
 # ((На името `beer` се присвоява обекта на изпълнения модул ))

== Търсене на файла ==
{{{python
import beer
}}}
Всички по реда на претърсване: списъка `sys.path`
Търси се в:
 # текущата директория
 # променливата на средата `PYTHONPATH`
 # системни директории с модули
 # директории, описани в `.pth` файлове

== Модул vs. Програма ==l

 * И в двата случая кодът ни се изпълнява
 * Искаме, ако кодът ни е бил изпълнен директно, да тестваме модула си
 * Искаме, ако кодът ни е бил включен с `import`, само да дефинираме фукнциите си
 * eater.py:
{{{python
def eat(what):
    print(what, "was eaten.")

if __name__ == '__main__':
    eat('The world as we know it')
}}}

{{{
[vladimiroff@latitude ~]$ python3 eater.py
The world as we know it was eaten.
>>> import eater
}}}


== Пакети от модули ==l
Представете си, че имаме две отделни системи, в които има модул на име `game`
{{{code
system1/
	game.py
	<други модули>
system2/
	game.py
	<други модули>

}}}

Сега напишете система, която използва модулите `game` и от двете системи:
{{{python
import game
game.play()
}}}

Тук вече имаме малък проблем.

== Пакети от модули (2) ==l
Би било много удобно ако можехме да разделим двата модула `game` в отделни пакети:
{{{python
import system1.game
import system2.game
system1.game.play()
system2.game.play()
}}}

Това е възможно при няколко условия:

 * директориите `system1` и `system2` са някъде из пътя за търсене на python
 * във всяка от тях има файл с име `__init__.py`

При `import` на по-сложно име се извършва следното:

 * намира се поредната компонента от пътя (разделени с точки)
 * ако има съответстващ файл &mdash; включва се
 * ако е директория &mdash; изпълнява се `__init__.py` в нея

== from mod import names ==
Това не ни ли е малко дълго `universe.milkyway.earth.europe.bg.beautify()`?
<br>

{{{python
from universe.milkyway.earth.europe.bg import beautify
beautify()
}}}
Или даже:
{{{python
from universe.milkyway.earth.europe.bg import beautify as b
b()
}}}

== from mod import * ==
Хубаво ли ви е така:
{{{python
from mod import a,b,c,d,e,f,g,h,i,j,k,l
}}}

И на мен. Затова Python ни позволява да внесем в нашия модул всички имена от някой друг: `from mod import *`

 * ((Имената от типа `_име` не се внасят))
 * ((Имената от типа `__име__` не се внасят))
 * ((Ако в `mod` има списък с име `__all__`, то се внасят само имената съдържащи се в него))


== Пакети от модули (3) ==ll
С пакети от модули можем с един замах да import-нем много модули:<br>
<em>forest/pooh.py:</em>
{{{python
name = 'Pooh'
pot = 'Full of honey'
}}}
<em>forest/piglet.py:</em>
{{{python
name = 'Piglet'
baloon = 'Red'
}}}
forest/__init__.py:
{{{python
from . import pooh
from . import piglet
pot = pooh.pot
baloon = piglet.baloon
}}}
user.py:
{{{python
import forest
print(forest.pooh.name)
print(forest.piglet.name)
print(forest.pot)
print(forest.baloon)
}}}

== import ==l

 * `import mod` &mdash; намира се модула и обектът му се присвоява на името `mod`
{{{python
>>> mod = 1
>>> import mod
>>> mod
&lt;module 'mod' from 'mod.py'&gt;
>>> 
}}}
 * модули в модули:
{{{python
mod.py
import sys

>>> import mod
>>> mod.sys
}}}

== import as ==
{{{python
import sys as sysmod
print(sysmod.path)
}}}

Почти същото е като:
{{{python
import sys
sysmod = sys
del sys
sysmod.path
}}}
само че ще загубим старата стойност на `sys`

{{{python
import forest.pooh.name as pooh_name
import forest.piglet.name as piglet_name
}}}

== Още разни модулни неща (1) ==
Съществува модул `builtins`, който съдържа всички вградени функции и други имена:
{{{python
import builtins
builtins.dir = abs
print(dir(-3))
}}}

== Още разни модулни неща (2) ==
Модулите се импортират само веднъж:
{{{python
>>> import world
>>> world.save('babas')
All the babas were saved.
>>> world.save = 5
>>> import world
>>> world.save
5
}}}

== Още разни модулни неща (3) ==
За презареждане трябва да се ползва `reload()`:
{{{python
>>> world.save
5
>>> from imp import reload
>>> reload(world)
>>> world.save
&lt;function save at 0x015001F0&gt;
}}}

== Още въпроси? ==

 * http://docs.python.org/py3k/tutorial/modules.html
 * Страница на курса - http://fmi.py-bg.net/
 * Форуми на курса - http://fmi.py-bg.net/topics/
 * Курсът в Twitter - http://twitter.com/pyfmi
