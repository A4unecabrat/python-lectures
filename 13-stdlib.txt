Разни библиотечки...
28.04.2011

== math ==
No comment

{{{python



import math

math.sin(1)
}}}


== datetime ==
`datetime` е модул, който ви дава основна функционалност за дати

 * `datetime.date(year, month, day)` - клас за дата
 * `datetime.time(hour, minute, second, microsecond, tzinfo=None)` - клас за време
 * `datetime.datetime(...)` - клас за дата и време
 * `datetime.timedelta` - разлика м/у `datetime.datetime`


== Пример с datetime ==l
{{{python
now     = datetime.datetime.now()
future  = now + datetime.timedelta(minutes=45)
past    = now - datetime.timedelta(minutes=45)
special = datetime.datetime(2009, 5, 11, 19, 0)

some_date = datetime.datetime.strptime(
		'11.05.2009 17:00', '%d.%m.%Y %H:%M')

hour = datetime.timedelta(minutes=30) * 2

print(now, future, past, special, some_date, sep='\n')
print(hour)
print(now.strftime('%d.%m.%Y %H:%M'))
}}}


== os ==ll
`os` - функционалност от операционната система
`os.path` - функционалност за работа с пътища във файловата система
 
 * `os.system(command)` - изпълнява командата
 * текущата директория - `os.chdir(path)` - сменя я ; `os.getcwd()` - дава я
 * `os.listdir(path)` - дава съдържанието на директорията
 * `os.makedirs(path)` - създава директория и родители
 * `os.remove(path)` - трие файл; `os.rmdir(path)` - трие ***празна*** директория
 * `os.stat(path)` - данни за файла
 * `os.walk(path)` - `for root, dirs, files in os.walk('/tmp/'): pass`
 * `os.path.abspath(path)` ; `os.path.basename(path)` ; `os.path.dirname(path)`
 * `os.path.exists(path)`
 * `os.path.isdir(path)`
 * ...


== pickle ==l
`pickle` е модул, който може да сериализира прости Python обекти.

 * `pickle.dump(object, file)`
    Приема binary отворен за писане файл file и Python обект object. Записва обекта в файла.
 * `pickle.load(file)`
    Приема binary отворен за четене файл и прочита един обект, който е и резултат от функцията 
 * `pickle.dumps(object)` - връща низ
 * `pickle.loads(str)` - връща обект от низ
 * може да бъде backward compatible с python 2 и 1


== Пример с pickle ==l
{{{python
import pickle

with open('/tmp/foo.txt', 'wb') as file:
    pickle.dump("The answer", file)
    pickle.dump(["spam", "eggs", "ham"], file)

with open('/tmp/foo.txt', 'rb') as file:
    print(pickle.load(file))
    print(pickle.load(file))
}}}


== shelve ==l
 * `shelve` е сравнително прост модул, който позволява да записвате данни във файл под формата на речник.
 * Можете да ги достъпвате в последствие по ключовете, с които сте ги записали.
 * Всички обекти се сериализират посредством `pickle`.
 * Организацията им във файла става посредством dbm или gdbm.
 * НЕ е thread-safe откъм писане
 * трябва да се внимава с mutable обектите


== Пример с shelve ==l
{{{python
import shelve

db = shelve.open('/tmp/foo.db')
db['name'] = 'Mityo the Python'
db['age'] = 33
db['favouriteBands'] = ["Blackmore's Night", "Deep Purple", "Rainbow"]
db['favouriteSong'] = "Colubrid on the Tree"
db.close()

db = shelve.open('/tmp/foo.db')
print(db.keys())
print(db['name'])
print(db['favouriteBands'])
print(db['favouriteSong'])
db.close()
}}}


== json ==l
`json` е модул, който може да сериализира прости Python обекти.

 * `json.dump(object, file)`
    Приема binary отворен за писане файл file и Python обект object. Записва обекта в файла.
 * `json.load(file)`
    Приема binary отворен за четене файл и прочита един обект, който е и резултат от функцията 
 * `json.dumps(object)` - връща низ
 * `json.loads(str)` - връща обект от низ


== Пример с json ==l
{{{
>>> import json
>>> json.dumps(['foo', {'bar': ('baz', None, 1.0, 2)}])
'["foo", {"bar": ["baz", null, 1.0, 2]}]'
>>> print(json.dumps("\"foo\bar"))
"\"foo\bar"
>>> print(json.dumps('\u1234'))
"\u1234"
>>> print(json.dumps('\\'))
"\\"
>>> print(json.dumps({"c": 0, "b": 0, "a": 0}, sort_keys=True))
{"a": 0, "b": 0, "c": 0}

>>> json.loads('["foo", {"bar":["baz", null, 1.0, 2]}]')
['foo', {'bar': ['baz', None, 1.0, 2]}]
}}}

== bytes ==
 * Примери `b'aa'` и `b'\x7f\x00'`
 * Много близки до низ
 * Могат да се конвертират до низ с `.decode(encoding)`
 * Низове могат да се конвертират до `bytes` с `.encode(encoding)`

== struct ==l
Понякога ни трябва нещо да сериализираме в нещо "low level" - нещо като за C
 * `struct.pack` - "опакова" неща в байтове
 * `struct.unpack` - "разопакова" неща в байтове
{{{

>>> struct.pack('bbH', 4,0,3)
b'\x04\x00\x03\x00'
>>> struct.unpack('bbH', b'\x04\x00\x03\x00')
(4, 0, 3)
}}}


== csv ==l
{{{python
import csv

with open('/tmp/eggs.csv', 'w') as file:
    spam_writer = csv.writer(file, delimiter=',', quotechar='"')
    spam_writer.writerow(['Spam'] * 2 + ['Baked Beans'])
    spam_writer.writerow(['Spam', 'Lovely Spam', 'Wonderful Spam'])

with open('/tmp/eggs.csv', 'r') as file:
    spam_reader = csv.reader(file, delimiter=',', quotechar='"')
    for row in spam_reader:
        print(' & '.join(row))
# Spam & Spam & Baked Beans
# Spam & Lovely Spam & Wonderful Spam
}}}


== configparser ==
`configparser` - модул за обработка на .conf файлове:

{{{bare
<pre>


[auth]
username = someone
password = somepass

[report]
url = http://docs.python.org
</pre>
}}}


== Пример с configparser ==l
{{{python
import configparser

config = configparser.ConfigParser()
config.add_section('auth')
config.set('auth', 'password', 'm@st@')

with open('/tmp/test.cfg', 'w') as file:
    config.write(file)

config = configparser.ConfigParser()
config.read('/tmp/test.cfg')

print(config.get('auth', 'password')) # -> "m@st@"
}}}


== getopt ==ll
`getopt` - parser за опции от командния ред

{{{python
import getopt, sys

def main():
    try:
        opts, args = getopt.getopt(sys.argv[1:], "ho:v", ["help", "output="])
    except getopt.GetoptError as err:
        print(err) # will print something like "option -a not recognized"
        print(usage())
        sys.exit(1)
    output, verbose = None, False
    for o, a in opts:
        if o == "-v": verbose = True
        elif o in ("-h", "--help"):
            usage()
            sys.exit()
        elif o in ("-o", "--output"): output = a
        else: assert False, "unhandled option"
    pass # TODO

if __name__ == "__main__":
    main()
}}}


== StringIO ==ll
Ами ако не искаме нещата да отиват във файл ами в низ.
 * поддържа `.read`, `.write` и подобни
 * взимаме стойността му с `.getvalue()`

{{{python

from io import StringIO

data = StringIO()

config = configparser.ConfigParser()
config.add_section('auth')
config.set('auth', 'password', 'm@st@')
config.write(data)

print(data.getvalue())
}}}


== xml.dom.minidom ==ll
`xml.dom.minidom` — Lightweight DOM implementation

{{{bare
<pre>
import xml.dom.minidom

document = """\
&lt;slideshow&gt;
&lt;title>Demo slideshow&lt;/title&gt;
&lt;slide>slide1&lt;/slide&gt;
&lt;slide>slide2&lt;/slide&gt;
&lt;/slideshow&gt;
"""

dom = xml.dom.minidom.parseString(document)
</pre>
}}}


== xml.dom.minidom(2) ==ll
{{{python
def getText(nodelist):
    rc = ""
    for node in nodelist:
        if node.nodeType == node.TEXT_NODE:
            rc = rc + node.data
    return rc

def handleSlideshow(slideshow):
    print("&lt;html&gt;&lt;title&gt;", 
          getText(slideshow.getElementsByTagName("title")[0].childNodes), 
          "&lt;/title&gt;&lt;body&gt;")
    handleSlides(slideshow.getElementsByTagName("slide"))
    print("&lt;/body&gt;&lt;/html&gt;")

def handleSlides(slides):
    for slide in slides:
        print('&lt;div id="slide"&gt;', 
              getText(slide.childNodes), 
              '&lt;/div&gt;')

handleSlideshow(dom)
}}}


== html parsing ==l
{{{python
from html.parser import HTMLParser

class MyHTMLParser(HTMLParser):

    def handle_starttag(self, tag, attrs):
        print("Encountered the beginning of a {0} tag".format(tag))

    def handle_endtag(self, tag):
        print("Encountered the end of a {0} tag".format(tag))
}}}

== urllib.request ==
`urllib.request` - за работа с http 

 * Има различни класове за всякакви неща...
 * Лесно се използва
 * в стария python за това служи `urllib2`

== Примери с urllib.request ==ll
{{{python
import urllib.request
import urllib.parse

params = urllib.parse.urlencode({'spam': 1, 'eggs': 2, 'bacon': 0})

#GET
f = urllib.request.urlopen("http://www.python.org/cgi-bin/query?{0}".format(params))
print(f.read())

# Същото с POST
f = urllib.request.urlopen("http://www.python.org/cgi-bin/post",
		           data=params)
print(f.read())
}}}


== Други ==
 * `hashlib`
 * `base64`
 * `email`
 * `mimetypes`
 * `logging`
 * ...


== Архивиране/компресия ==
 * `zlib`
 * `gzip`
 * `bz2`
 * `zipfile`
 * `tarfile`


== Още въпроси? ==
 * Страница на курса: http://fmi.py-bg.net/
 * Форуми на курса: http://fmi.py-bg.net/topics/